<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="心态在线，激情在线，健康在线，才能创造未来！">
<meta name="keywords" content="littleshuai">
<meta property="og:type" content="website">
<meta property="og:title" content="机灵猴">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="机灵猴">
<meta property="og:description" content="心态在线，激情在线，健康在线，才能创造未来！">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="机灵猴">
<meta name="twitter:description" content="心态在线，激情在线，健康在线，才能创造未来！">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/">





  <title>机灵猴</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">机灵猴</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">一只调皮的程序媛！</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/17/YYKit源码解析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="aHuang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="机灵猴">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/17/YYKit源码解析/" itemprop="url">YYKit源码解析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-17T09:08:11+08:00">
                2019-04-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>YYKit是iOS组件的集合，这个框架的代码量很大，这里就分出几个独立的部分。<br>YYModel - iOS高性能模型框架<br>YYCache - iOS高性能缓存框架<br>YYImage - iOS的图像框架用于显示/编码/解码动画WebP，APNG，GIF<br>YYWebImage - 异步图像加载框架<br>YYText - iOS中强大的文本组件<br>YYKeyboardManager - 访问键盘视图并跟踪键盘动画<br>YYDispatchQueuePool - iOS实用程序类来管理全局调度队列<br>YYAsyncLayer - 用于异步渲染和显示的iOS实用程序类<br>YYCategories - Foundation和UIKit的一组有用分类。。<br><!--阅读全文--></p>
<p>#pragma mark - UIFont 分类- Create font<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.+ (nullable UIFont *)fontWithCTFont:(CTFontRef)CTFont;</span><br><span class="line"></span><br><span class="line">1.+ (nullable UIFont *)fontWithCGFont:(CGFontRef)CGFont size:(CGFloat)size;</span><br><span class="line"></span><br><span class="line">1.+ (nullable CTFontRef)CTFontRef CF_RETURNS_RETAINED;</span><br><span class="line"></span><br><span class="line">1.+ (nullable CGFontRef)CGFontRef CF_RETURNS_RETSINED;</span><br></pre></td></tr></table></figure></p>
<p>#pragma mark - UIFont 分类- Load and unload font<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.+ (BOOL)loadFontFromPath:(NSString *)path;// 从文件路径加载字体。支持格式：TTF，OTF。如果返回YES，字体可以使用PostScriptName：[UIFont fontWithName：...]进行加载；</span><br><span class="line"></span><br><span class="line">1.+ (void)unloadFontFromPath:(NSString *)path;// 从文件路径中卸载字体</span><br><span class="line"></span><br><span class="line">1.+ (nullable UIFont *)loadFontFromData:(NSData *)data;// 从data加载字体，支持格式：TTF，OTF</span><br><span class="line"></span><br><span class="line">1.+ (BOOL)unloadFontFromData:(UIFont *)font;// 从data写卸载字体</span><br></pre></td></tr></table></figure></p>
<p>#pragma mark - UIFont 分类- Dump font data<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.+ (nullable NSData *)dataFromFont:(UIFont *)font;// 根据UIFont对象，进行序列化，返回NSData类型的数据</span><br><span class="line"></span><br><span class="line">1.+ (nullable NSData *)dataFromCGFont:(CGFontRef)cgFont;// 根据CGFontRef返回一个NSData的数据类型</span><br></pre></td></tr></table></figure></p>
<p>#pragma mark - UIImage分类之框架结构和create image部分</p>
<p>   UIImage框架结构：Create Image，Image Info，Modify Image，Image Effect<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"> + (nullable UIImage *)imageWithSmallGIFData:(NSData *)data scale:(CGFloat)scale</span><br><span class="line"> //根据GIF data对象创建动画图像。在创建之后，你可以通过属性.images获取images，如果data不是动画GIF，这个功能和[UIImage imageWithData:data scale:scale]是一样的；它具有更好的显示性能，但是成本更高（宽高帧字节）。它只适用于显示动画表情符号等小gif。如果你想显示大的GIF，请参阅YYImage；</span><br><span class="line"> </span><br><span class="line"> + (BOOL)isAnimatedGIFData:(NSData *)data;</span><br><span class="line"> // 判断是否data是动画GIF，如果data是GIF并且包含超过一帧就返回YES，否则返回NO；</span><br><span class="line"> </span><br><span class="line"> + (BOOL)isAnimatedGIFFile:(NSString *)path;</span><br><span class="line"> // 判断指定路径的文件是否是GIF；</span><br><span class="line"> </span><br><span class="line"> + (nullable UIImage *)imageWithPDF:(id)dataOrPath;</span><br><span class="line"> //根据PDF文件数据data或者路径创建image，如果PDF有多个页面，则只是返回第一页的内容，图像的比例等于当前屏幕的比例，尺寸与PDF的原始尺寸相同。参数dataOrPath的作用是NSData类型的PDF数据或者NSString类型的文件路径；</span><br><span class="line"> </span><br><span class="line"> + (nullable UIImage *)imageWithPDF:(id)dataOrPath size:(CGSize)size;</span><br><span class="line"> //根据指定的PDF文件数据或者路径创建图像image，如果PDF有多个页面，则只是返回第一页的内容。图像的比例等于当前屏幕的比例，参数size是新图片的大小，PDF的内容将根据需要延展；</span><br><span class="line"> </span><br><span class="line"> + (nullable UIImage *)imageWithEmoji:(NSString *)emoji size:(CGFloat)size;</span><br><span class="line"> //从苹果表情符创建一个方形图像。它从苹果表情符创建一个方形图像，图像比例等于当前屏幕的比例。Apple Color Emoji(比如：@&quot;🌹&quot;)字体中的原始表情符号图像大小为160*160像素；</span><br><span class="line"> </span><br><span class="line"> + (nullable UIImage *)imageWithColor:(UIColor *)color;</span><br><span class="line"> // 用给定的颜色创建并返回1X1点大小的图像</span><br><span class="line"> </span><br><span class="line"> + (nullable UIImage *)imageWithColor:(UIColor *)color size:(CGSize)size;</span><br><span class="line"> // 创建并返回具有给定颜色和大小的纯色图像</span><br><span class="line"> </span><br><span class="line"> + (nullable UIImage *)imageWithSize:(CGSize)size drawBlock:(Void(^)(CGContextRef context))drawBlock;</span><br><span class="line"> // 用自定义绘图代码创建并返回图像，drawBlock里面写需要实现的代码才能真正实现图像；</span><br><span class="line"></span><br><span class="line">[UIImage imageWithSmallGIFData:[NSData data] scale:[UIScreen mainScreen].scale];</span><br><span class="line">[UIImage isAnimatedGIFData:[NSData data]];</span><br><span class="line">[UIImage imageWithPDF:[NSData data]];</span><br><span class="line">UIImage *emojiImage = [UIImage imageWithEmoji:@&quot;🌹&quot; size:160];</span><br></pre></td></tr></table></figure></p>
<p>#pragma mark - UIImage分类之框架结构和create image部分<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)hasAlphaChannel;</span><br><span class="line">判断图像是否有alpha通道。</span><br></pre></td></tr></table></figure></p>
<p>#pragma mark - UIImage分类之框架结构和Modify image部分<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">- (void)drawInRect:(CGRect)rect withContentMode:(UIViewContentMode)contentMode clipsToBounds:(BOOL)clips;</span><br><span class="line">在指定的矩形中绘制整个图像，使用contentMode更改内容。在当前图形上下文中绘制整个图像，并考虑图像的方向设置。在默认坐标系中，图像位于指定矩形的原点的右下方。但是，此方法应用于当前图形上下文的任何转换。</span><br><span class="line"></span><br><span class="line">- (nullable UIImage *)imageByResizeToSize:(CGSize)size;</span><br><span class="line">将原图像进行缩放，图像会根据需要进行延展。</span><br><span class="line"></span><br><span class="line">- (nullable UIImage *)imageByResizeToSize:(CGSize)size contentMode:(UIViewContentMode)contentMode;</span><br><span class="line">将原图像进行缩放，这里会根据指定的contentMode进行缩放</span><br><span class="line"></span><br><span class="line">- (nullable UIImage *)imageByCropToRect:(CGRect)rect;</span><br><span class="line">对图像进行指定大小区域的裁剪</span><br><span class="line"></span><br><span class="line">- (nullable UIImage *)imageByInsetEdge:(UIEdgeInsets)insets withColor:(nullable UIColor *)color;</span><br><span class="line">返回一个图像，该图像是在原图像的基础上缩进或者外扩一定得边距的结果：</span><br><span class="line">insets：内向为正，外向为负</span><br><span class="line">color：边界的填充颜色，如果是nil就是clear color</span><br><span class="line"></span><br><span class="line">- (nullable UIImage *)imageByRoundCornerRadius:(CGFloat)radius;</span><br><span class="line">带一定圆角的图像：radius：每个角落椭圆的半径。大于矩形宽度或高度一半的值将被适当的限制为宽或高的一半；</span><br><span class="line"></span><br><span class="line">- (nullable UIImage *)imageByRoundCornerRadius:(CGFloat)radius borderWidth:(CGFloat)borderWidth borderColor:(nullable UIColor *)borderColor;</span><br><span class="line">获取指定圆角，边线宽度和边界颜色的图像；</span><br><span class="line">radius：圆角大小，大于矩形宽或高的时候，被适当的限制为宽或高的一半；</span><br><span class="line">borderWidth：内边线宽，大于矩形宽或高的时候，被适当的限制为宽或高的一半。</span><br><span class="line">borderColor：边线的颜色，nil表示clear color</span><br><span class="line"></span><br><span class="line">- (nullable UIImage *)imageByRoundCornerRadius:(CGFloat)radius corners:(UIRectCorner)corners borderWidth:(CGFloat)borderWidth borderColor:(nullable UIColor *)borderColor borderLineJoin:(CGLineJoin)borderLineJoin;</span><br><span class="line">获取指定圆角、线宽、线色以及连接类型的图像。</span><br><span class="line"></span><br><span class="line">- (nullable UIImage *)imageByRotate:(CGFloat)radians fitSize:(BOOL)fitSize;</span><br><span class="line">返回一个旋转的图像。</span><br><span class="line">radians：逆时针旋转弧度</span><br><span class="line">fitSize：YES，新图片的大小被扩展到适合所有内容；NO，图片的大小不会改变，内容可能会被裁剪。</span><br><span class="line"></span><br><span class="line">- (nullable UIImage *)imageByRotateLeft90;</span><br><span class="line">逆时针旋转90度，图像和宽高将会交换。</span><br><span class="line"></span><br><span class="line">- (nullable UIImage *)imageByRotateRight90;</span><br><span class="line">右旋转90度，图像宽高将会交换。</span><br><span class="line"></span><br><span class="line">- (nullabel UIImage *)imageByTotate180;</span><br><span class="line">旋转180度。</span><br><span class="line"></span><br><span class="line">- (nullable UIImage *)imageByFlipVertical;</span><br><span class="line">垂直翻转后的图像；</span><br><span class="line"></span><br><span class="line">- (nullable UIImage *)imageByFlipHorizontal;</span><br><span class="line">水平翻转后的图像。</span><br></pre></td></tr></table></figure></p>
<p>#pragma mark - UIImage分类之框架结构和 Image Effect 部分<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">- (UIImage *)imageByTintColor:(UIColor *)color;</span><br><span class="line">用给定颜色在alpha通道中国对图像着色</span><br><span class="line"></span><br><span class="line">- (nullabel UIImage *)imageByGrayscale;</span><br><span class="line">灰度图像；// 用到了OpenGL的相关知识</span><br><span class="line"></span><br><span class="line">- (nullable UIImage *)imageByBlurSoft;</span><br><span class="line">对此图像应用模糊效果，适合模糊任何内容</span><br><span class="line"></span><br><span class="line">- (nullable UIImage *)imageByBlurLight;</span><br><span class="line">对此图像应用模糊效果，适用于模糊除纯白色以外的任何内容；</span><br><span class="line"></span><br><span class="line">- (nullable UIImage *)imageByBlurExtraLight;</span><br><span class="line">对此图像应用模糊效果，适合显示黑色文本。（与ios导航栏白色相同）</span><br><span class="line"></span><br><span class="line">- (nullable UIImage *)imageByBlurDark;</span><br><span class="line">对此图像应用模糊效果，适合显示白色文本，（与iOS通知中心相同）</span><br><span class="line"></span><br><span class="line">- (nullabel UIImage *)imageByBlurWithTint:(UIColor *)tintColor;</span><br><span class="line">对此图像应用模糊和色调颜色</span><br><span class="line"></span><br><span class="line">- (nullable UIImage *)imageByBlurRadius:(CGFloat)blurRadius tintColor:(nullable UIColor *)tintColor tintMode:(CGBlendMode)tintBlendMode saturation:(CGFloat)saturation maskImage:(nullable UIImage *)maskImage;</span><br><span class="line">对此图像应用模糊，色调和饱和度调整，可选地在由maskImage指定区域内；</span><br><span class="line">blurRadius：模糊点的半径，0表示没哟模糊效果；</span><br><span class="line">tintColor：与模糊和饱和度操作的结果均匀混合的可选UIColor对象。这种颜色的alpha通道决定着色的强度。nil意味着没有色彩；</span><br><span class="line">tintBlendMode：混合模式，默认kCGBlendModeNormal</span><br><span class="line">saturation：1.0的值在结果图像不产生变化，小于1.0的值会使得到的图像去饱和，大于1.0的值则会产生相反的效果，0表示灰度；</span><br><span class="line">maskImage：如果指定，则 inputImage仅在由此掩码定义的区域中进行修改。这必须是一个图像掩码，或者它必须满足CGContextClipToMask的掩码参数的要求；</span><br></pre></td></tr></table></figure></p>
<p>#pragma mark - UIImageView分类之架构和image部分<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">UIImageView的基本框架：UIImageView-》image ；UIImageView-》highlight image</span><br><span class="line">这个分类其实和SDWebImage中有关图像下载部分都是类似的；</span><br><span class="line">用到了：runtime，GCD异步线程，线程等待，单列线程，图片缓存和首先从缓存或磁盘中获取已经缓存的图片，如果没有再从网络获取并缓存；整个过程都在异步线程中；</span><br><span class="line"></span><br><span class="line">@property(nullable,nonatomic,strong) NSURL *imageURL;</span><br><span class="line">该属性是当前图像的URL；为此属性设置一个新值将取消先前的请求操作并创建一个新的请求操作来获取图像。设置nil以清除图片和图片URL地址；</span><br><span class="line"></span><br><span class="line">- (void)setImageWithURL:(nullable NSURL *)imageURL placeholder:(nullable UIImage *)placeholder;</span><br><span class="line">就是和SDWebImage一样的；</span><br><span class="line"></span><br><span class="line">- (void)setImageWithURL:(nullabel NSURL *)imageURL options:(YYWebImageOptions)options;</span><br><span class="line">这个方法作用就是下载图像，options下载请求时用到的选项；</span><br><span class="line">YYWebImageManager: 用来创建图像请求操作的管理者；</span><br><span class="line"></span><br><span class="line">- (void)cancelCurrentImageRequest;</span><br><span class="line">取消当前图像下载；</span><br></pre></td></tr></table></figure></p>
<p>#pragma mark - UIImageView分类之架构和highlight image部分<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">与UIImageView分类之架构和image部分类似，不同的是这个是高亮状态；</span><br><span class="line"></span><br><span class="line">- (void)setHignLightedImageWithURL:(nullable NSURL *)imageURL placeholder:(nullable UIImage *)placeHolder;</span><br><span class="line">根据给定的URL设置下载的图片；</span><br><span class="line"></span><br><span class="line">- (void)cancelCurrentHighlightedImageRequest;</span><br><span class="line">取消下载高亮图片；</span><br></pre></td></tr></table></figure></p>
<p>#pragma mark - UIScreen 分类<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">+ (CGFloat)screenScale;</span><br><span class="line">返回屏幕的尺寸比例:GCD</span><br><span class="line"></span><br><span class="line">- (CGRect)currentBounds;</span><br><span class="line">返回当前屏幕的大小: 判断横屏还是竖屏</span><br><span class="line"></span><br><span class="line">- (CGRect)boundsForOrientation:(UIInterfaceOrientation)orientation;</span><br><span class="line">返回给定设备方向的屏幕边界尺寸。UIScreen的bounds方法总是以纵向方向返回它的屏幕边界；</span><br><span class="line"></span><br><span class="line">@property(nonatomic, readonly)CGSize sizeInPixel;</span><br><span class="line">该属性的意义就是屏幕的像素实际尺寸（宽度始终小于高度），该值在未知设备或模拟器中可能不太准确。例如（768，1024）。</span><br><span class="line"></span><br><span class="line">@property(nonatomic,readonly)CGFloat pixelsPerInch;</span><br><span class="line">该属性的作用就是获取每英寸的像素数目，也就是屏幕的PPI，这个值在未知设备和模拟器中可能不是很准确，默认值是96；</span><br></pre></td></tr></table></figure></p>
<p>#pragma mark - UIScrollView 分类<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (void)scrollToTop;</span><br><span class="line">滚动内容到顶部；</span><br><span class="line"></span><br><span class="line">- (void)scrollToBottom;</span><br><span class="line">滚动内容到底部；</span><br><span class="line"></span><br><span class="line">- (void)scrollToLeft;</span><br><span class="line">滚动内容到左侧；</span><br><span class="line"></span><br><span class="line">- (void)scrollToRight;</span><br><span class="line">滚动内容到右侧；</span><br></pre></td></tr></table></figure></p>
<p>#pragma mark - UITableView 分类<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (void)updateWithBlock:(void(^)(UITableView *tableView))block;</span><br><span class="line">执行一系列方法调用，以插入，删除或选择行和部分；如果希望后续插入，删除和选择操作（如cellForRowAtIndexPath：和indexPathsForVisibleRows）同时进行动画，请调用此方法；如果您不在该块内进行插入，删除和选择调用，则table属性（如行数）可能失效。您不应该在块中调用reloaddata；如果您在组中调用此方法，则需要自己执行任何动画。</span><br><span class="line"></span><br><span class="line">- (void)scrollToRow:(NSUInteger)row inSection:(NSUInteger)section atScrollPosition:(UITableViewScrollPosition)scrollPosition animated:(BOOL)animated;</span><br><span class="line">滚动到屏幕指定的行或者section。调用此方法不会导致代理接收scrollViewDidScroll：消息，正如程序调用的用户界面操作一样；</span><br><span class="line"></span><br><span class="line">- (void)insertRow:(NSUInteger)row inSection:(NSUInteger)section withRowAnimation:(UITableViewRowAnimation)animation;</span><br><span class="line">插入一行到指定的位置，可动画；</span><br><span class="line"></span><br><span class="line">- (void)reloadRow:(NSUInteger)row inSection:(NSUInteger)section withRowAnimation:(UITableViewRowAnimation)animation;</span><br><span class="line">使用指定的动画效果刷新指定的行；</span><br></pre></td></tr></table></figure></p>
<p>#pragma mark - UITextField 分类<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (void)selectAllText;</span><br><span class="line">选择所有的文本</span><br><span class="line"></span><br><span class="line">- (void)setSelectedRange:(NSRange)range;</span><br><span class="line">选择指定范围内部的文本</span><br></pre></td></tr></table></figure></p>
<p>#pragma mark - UIView 分类<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">- (nullabel UIImage *)snapshotImage;</span><br><span class="line">创建完整视图层次结构的快照映像</span><br><span class="line"></span><br><span class="line">- (nullabel UIImage *)snapshotImageAfterScreenUpdates:(BOOL)afterUpdates;</span><br><span class="line">创建完整视图层次结构的快照映像，它比snapshotImage快，但可能导致屏幕更新。</span><br><span class="line"></span><br><span class="line">- (nullable NSData *)snapshotPDF;</span><br><span class="line">创建完整视图层次结构的快照PDF；</span><br><span class="line"></span><br><span class="line">- (void)setLayerShadow:(nullable UIColor *)color offset:(CGSize)offset radius:(CGFloat)radius;</span><br><span class="line">设置layer的阴影；</span><br><span class="line"></span><br><span class="line">- (void)removeAllSubviews;</span><br><span class="line">移除所有子视图</span><br><span class="line">注意：不要在view的drawRect: 方法里面调用这个方法。</span><br><span class="line"></span><br><span class="line">@property(nullable,nonatomic,readonly) UIViewController *viewController;</span><br><span class="line">获取view的viewController，可能为nil。</span><br><span class="line"></span><br><span class="line">@property(nonatomic,readonly)CGFloat visibleAlpha;</span><br><span class="line">考虑到父视图和window，返回屏幕上的可见alpha；</span><br><span class="line"></span><br><span class="line">- (CGPoint)convertPoint:(CGPoint)point toViewOrWindow:(nullable UIView *)view;</span><br><span class="line">两个视图上的点的转换。</span><br><span class="line"></span><br><span class="line">- (CGPoint)convertPoint:(CGPoint)point fromViewOrWindow:(nullable UIView *)view;</span><br><span class="line">两个视图上的点的转换，与上面那个方法不同的是，这里是从别的view到receiver的点的转换。</span><br><span class="line"></span><br><span class="line">- (CGRect)convertRect:(CGRect)rect toViewOrWindow:(nullable UIView *)view;</span><br><span class="line">就是两个视图上的rect的转换；</span><br><span class="line"></span><br><span class="line">- (CGRect)convertRect:(CGRect)rect fromViewOrWindow:(nullable UIView *)view;</span><br><span class="line">两个视图上的rect的转换，与上面那个方法不同的是，这里是从别的view到receiver的rect的转换；</span><br></pre></td></tr></table></figure></p>
<p>#pragma mark - UIPasteboard 分类: 粘贴板<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@property(nullable,nonatomic,copy)NSData *PNGData;</span><br><span class="line">获取PNG文件属性；</span><br><span class="line"></span><br><span class="line">@property(nullable,nonatomic,copy)NSData *JPEGData;</span><br><span class="line">获取JPEG文件数据；</span><br><span class="line"></span><br><span class="line">@property(nullable,nonatomic,copy)NSData *GIFData;</span><br><span class="line">获取GIF文件数据；</span><br><span class="line"></span><br><span class="line">@property(nullable,nonatomic,copy)NSData *WEBPData;</span><br><span class="line">获取webp文件数据；</span><br><span class="line"></span><br><span class="line">@property(nullable,nonatomic,copy) NSData *imageData;</span><br><span class="line">获取图像文件数据。</span><br><span class="line"></span><br><span class="line">@property(nullable,nonatomic,copy)NSAttributedString *attributedString;</span><br><span class="line">设置此属性还将设置属性字符串中的字符串属性，如果属性字符串包含一个或多个图像，它也会设置images属性；</span><br></pre></td></tr></table></figure></p>
<p>#pragma mark - UIGestureRecognizer 分类<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)initWithActionsBlock:(void(^)(id sender))block;</span><br><span class="line">用action块初始化已分配的手势识别器对象；block：处理接收器识别的手势action块，nil无效，它由手势保留；返回值为具体UIGestureRecognizer子类的初始化实例，如果尝试初始化对象时发生错误，则为nil。</span><br><span class="line">用到了runtime的思想；</span><br><span class="line"></span><br><span class="line">- (void)addActionBlock:(void(^)(id sender))block;</span><br><span class="line">为手势对象添加actionBlock，它由手势保留；</span><br><span class="line"></span><br><span class="line">- (void)removeAllActionBlocks;</span><br><span class="line">移除所有的动作块；</span><br></pre></td></tr></table></figure></p>
<p>#pragma mark - UIDevice分类框架 及 Device Information<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">UIDevice 分类的框架：Device Information，Network Information，Disk Space，CPU Information，Memory Information。</span><br><span class="line">+ (double)systemVersion;</span><br><span class="line">返回系统的版本；</span><br><span class="line"></span><br><span class="line">@property(nonatomic,readonly)BOOL isPad;</span><br><span class="line">判断设备是否是iPad和iPad mini；</span><br><span class="line"></span><br><span class="line">@property(nonatomic,readonly)BOOL isSimulator;</span><br><span class="line">判断设备是否是模拟器；</span><br><span class="line"></span><br><span class="line">@property(nonatomic,readonly)BOOL isJailbroken;</span><br><span class="line">判断设备是否是越狱机；</span><br><span class="line"></span><br><span class="line">@property(nonatomic,readonly)BOOL canMakePhoneCalls;</span><br><span class="line">判断是否可以打电话；</span><br><span class="line"></span><br><span class="line">@property(nullable,nonatomic,readonly)NSString *machineModel;</span><br><span class="line">判断机型，比如“iPhone6,1”&quot;iPad4,6&quot;.</span><br><span class="line"></span><br><span class="line">@property(nullable,nonatomic,readonly)NSString *machineModelName;</span><br><span class="line">用来判断机型名称，比如&quot;iPhone 5s&quot;,&quot;iPad mini 2&quot;</span><br><span class="line"></span><br><span class="line">@property(nonatomic,readonly)NSDate *systemUptime;</span><br><span class="line">获取系统开始时间: 上次启动时间</span><br></pre></td></tr></table></figure></p>
<p>#pragma mark - UIDevice分类框架及Network Information<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@property(nullable,nonatomic,readonly)NSString *ipAddressWIFI;</span><br><span class="line">获取设备的WIFI IP地址，例如：192.168.1.111</span><br><span class="line"></span><br><span class="line">@property(nullable,nonatomic,readonly)NSString *ipAddressCell;</span><br><span class="line">设备的cell ip地址，例如：@&quot;10.2.2.222&quot;</span><br><span class="line"></span><br><span class="line">枚举 YYNetworkTrafficType</span><br><span class="line">WWAN：Wireless Wide Area Network ，For Example： 3G/4G</span><br><span class="line">WIFI：wi-fi</span><br><span class="line">AWDL：Apple Wireless Direct Link （peer-to-peer connection）for example：AirDrop，AirPlay，GameKit。</span><br><span class="line"></span><br><span class="line">- (uint64_t)getNetworkTrafficBytes:(YYNetworkTrafficType)types;</span><br><span class="line">获取设备网络流量字节，这是自设备上次启动以来的计数器。</span><br><span class="line">GCD: dispatch_semaphore_t 线程锁</span><br></pre></td></tr></table></figure></p>
<p>#pragma mark - UIDevice分类框架及 Disk Space<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@property(nonatomic,readonly)int64_t diskSpace;</span><br><span class="line">获取设备的磁盘空间；</span><br><span class="line"></span><br><span class="line">@property(nonatomic,readonly)int64_t diskSpaceFree;</span><br><span class="line">获取设备的可用磁盘空间；</span><br><span class="line"></span><br><span class="line">@property(nonatomic,readonly)int64_t diskSpaceUsed;</span><br><span class="line">获取设备使用的空间;</span><br></pre></td></tr></table></figure></p>
<p>#pragma mark - UIDevice分类框架及 Memory Information<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@property(nonatomic,readonly)int64_t memoryTotal;</span><br><span class="line">获取设备的内存总量；</span><br><span class="line"></span><br><span class="line">@property(nonatomic,readonly)int64_t memoryUsed;</span><br><span class="line">获取设备使用的内存总量；</span><br><span class="line"></span><br><span class="line">@property(nonatomic,readonly)int64_t memoryFree;</span><br><span class="line">获取设备可用的内存总量。</span><br><span class="line"></span><br><span class="line">@property(nonatomic,readonly)int64_t memoryActive;</span><br><span class="line">获取设备活动内存；</span><br><span class="line"></span><br><span class="line">@property(nonatomic,readonly)int64_t memoryInactive;</span><br><span class="line">获取设备非活动内存</span><br><span class="line"></span><br><span class="line">@property(nonatomic,readonly)int64_t memoryWired;</span><br><span class="line">获取设备的wired memory。</span><br><span class="line"></span><br><span class="line">@property(nonatomic,readonly)int64_t memoryPurgable;</span><br><span class="line">获取设备purgable memory；</span><br></pre></td></tr></table></figure></p>
<p>#pragma mark - UIDevice分类框架及 CPU Information<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@property(nonatomic,readonly)NSUInteger cpuCount;</span><br><span class="line">获取当前的进程数；</span><br><span class="line"></span><br><span class="line">@property(nonatomic,readonly)float cpuUsage;</span><br><span class="line">获取CPU使用率，1.0代表100%；</span><br><span class="line"></span><br><span class="line">@property(nonatomic,readonly)NSArray&lt;NSNumber *&gt; *cpuUsagePerProcessor;</span><br><span class="line">获取每个进程对应的CPU使用，1.0 代表100%；</span><br></pre></td></tr></table></figure></p>
<p>#pragma mark - UIControl 分类<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (void)removeAllTargets;</span><br><span class="line">从一个内部的dispatch table中移除某一特定event的所有的targets和actions。</span><br><span class="line">注册的事件，不进已经被加入到事件当中，会被识别，，同时，将信息注入到列表，可被查询，可被修改。</span><br><span class="line"></span><br><span class="line">- (void)setTarget:(id)target action:(SEL)action forControlEvents:(UIControlEvents)controlEvents;</span><br><span class="line">为某一特定的event添加或者移除target和action到一个内部dispatch table。</span><br><span class="line">target：目标对象-即消息发送到的对象，如果这是nil，响应者链会搜索一个愿意回应该动作消息的对象；</span><br><span class="line">action：一个标识动作消息的选择器，它不能为NULL；</span><br><span class="line">controlEvents：指定发送操作消息的控件事件的位掩码；</span><br><span class="line"></span><br><span class="line">- (void)addBlockForControlEvents:(UIControlEvents)controlEvents block:(void(^)(id sender))block;</span><br><span class="line">将特定事件（或事件）的块添加到内部dispatch table 中。它会引起对@a block 的强引用；</span><br><span class="line"></span><br><span class="line">- (void)setBlockForControlEvents:(UIControlEvents)controlEvents block:(void(^)(id sender))block;</span><br><span class="line">将特定事件（或事件）的块添加或替换到内部dispatch table中。它会引起对@a block的强烈引用。</span><br><span class="line">block：当action消息被发送时调用block（不能为nil），该块被引用。</span><br><span class="line">controlEvents：指定发送操作消息的控件事件的位掩码</span><br><span class="line"></span><br><span class="line">- (void)removeAllBlocksForControlEvents:(UIControlEvents)controlEvents;</span><br><span class="line">将内部dispatch table中特定事件或事件的所有block移除；</span><br><span class="line">controlEvents：指定发送操作消息的控件事件的位掩码；</span><br></pre></td></tr></table></figure></p>
<p>#pragma mark - UIColor 分类 之Create a UIColor Object<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">该分类的框架结构：Create a UIColor Object，Get Color’s description，Retrieving Color Information。</span><br><span class="line"></span><br><span class="line">+ (UIColor *)colorWithHue:(CGFloat)hue saturation:(CGFloat)saturation lightness:(CGFloat)lightness alpha:(CGFloat)alpha;</span><br><span class="line">使用指定的不透明度和HSL颜色空间分量值创建并返回一个颜色对象；</span><br><span class="line">hue：HSL颜色空间的颜色对象的hue分量，值为0.0-1.0；</span><br><span class="line">saturation：HSL颜色空间的颜色对象的saturation：HSL分量，值为0.0-1.0；</span><br><span class="line">lightness：HSL颜色空间的颜色对象的lightness：HSL分量，值为0.0-1.0；</span><br><span class="line">alpha：不透明度，0.0-1.0之间；</span><br><span class="line"></span><br><span class="line">+ (UIColor *)colorWithCyan:(CGFloat)cyan magenta:(CGFLoat)magenta yellow:(CGFloat)yellow black:(CGFLoat)black alpha:(CGFloat)alpha;</span><br><span class="line">使用指定的不透明度和CMYK颜色空间分量值创建并返回一个颜色对象；值：0.0-1.0</span><br><span class="line">返回值为RGB颜色空间的颜色对象；</span><br><span class="line"></span><br><span class="line">+ (nullable UIColor *)colorWithHexString:(NSString *)hexStr;</span><br><span class="line">根据指定的hex 字符串创建并返回颜色对象。</span><br><span class="line"></span><br><span class="line">+ (UIColor *)colorByAddColor:(UIColor *)add blendMode:(CGBlendMode)blendMode;</span><br><span class="line">在原来颜色的基础上，混入新的颜色，并根据混合模式创建新的颜色对象；</span><br></pre></td></tr></table></figure></p>
<p>#pragma mark - UIButton 分类 之 image<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">框架结构：image，backgroundImage</span><br><span class="line">- (nullabel NSURL *)imageURLForState:(UIControlState)state;</span><br><span class="line">返回按钮指定状态的URL地址；还是用到了runtime,GCD,缓存 的方法；</span><br><span class="line"></span><br><span class="line">- (void)setImageWithURL:(nullable NSURL *)imageURL forState:(UIControlState)state placeholder:(nullable UIImage *)placeholder;</span><br><span class="line">给按钮设置指定URL地址的图像；</span><br><span class="line"></span><br><span class="line">- (void)cancelImageRequestForState:(UIControlState)state;</span><br><span class="line">取消当前图像对指定状态的请求；</span><br></pre></td></tr></table></figure></p>
<p>#pragma mark - UIButton 分类 之 backgroundImage<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (void)backgroundImageURLForState:(UIControlState)state;</span><br><span class="line"></span><br><span class="line">- (void)setBackgroundImageWithURL:(nuallbel NSURL *)imageURL forState:(UIControlState)state placeholder:(nullabel UIImage *)placeholder;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">跟image 实现方法是一样的；</span><br></pre></td></tr></table></figure></p>
<p>#pragma mark - UIBezierPath 分类<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ (nullabel UIBezierPath *)bezierPathWithText:(NSString *)text font:(UIFont *)font;</span><br><span class="line">创建并返回一个新的UUIBezierPath对象，该对象使用从指定字体生成的文本字形进行初始化；</span><br><span class="line">它不支持苹果表情符号，如果你想获得表情符号图片，请尝试使用UIImage（YYAdd）中的[UIImage imageWithEmoji:size:].</span><br></pre></td></tr></table></figure></p>
<p>#pragma mark - UIBarButtonItem 分类<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@property(nullabel,nonatomic,copy)void(^actionBlock)(id);</span><br><span class="line">当Item被选择的时候调用这个block，block捕获的对象将被buttonItem持有；</span><br><span class="line">这个参数与target 和 action属性冲突，设置这个，将会对内部对象的target 和 action属性进行设置；</span><br></pre></td></tr></table></figure></p>
<p>#pragma mark - UIApplication 分类<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">@property(nonatomic,readonly)NSURL *documentsURL;</span><br><span class="line">获取documents的文件目录；</span><br><span class="line"></span><br><span class="line">@property(nonatomic,readonly)NSString *documentsPath;</span><br><span class="line">获取documents的文件目录；</span><br><span class="line"></span><br><span class="line">@property(nonatomic,readonly)NSURL *cachesURL;</span><br><span class="line">获取cache的文件目录；</span><br><span class="line"></span><br><span class="line">@property(nonatomic,readonly)NSString *cachesPath;</span><br><span class="line">获取cache的文件目录；</span><br><span class="line"></span><br><span class="line">@property (nonatomic, readonly) NSURL *libraryURL;</span><br><span class="line">这个属性的作用就是获取library的文件目录。</span><br><span class="line"></span><br><span class="line">@property (nonatomic, readonly) NSString *libraryPath;</span><br><span class="line">这个属性的作用就是获取library的文件目录。</span><br><span class="line"></span><br><span class="line">@proprty(nullabel,nonatomic,readonly)NSString *appBundleName;</span><br><span class="line">获取APPlication‘s bundle name</span><br><span class="line"></span><br><span class="line">@property(nonatomic,readonly)BOOL isPirated;</span><br><span class="line">判断是否是盗版的，也就是不是从apple store中下载的；</span><br><span class="line">如果有人真的想破解你的应用程序，这个方法是没用的。</span><br><span class="line">您可以更改此方法的名称、加密代码并进行更多检查</span><br><span class="line"></span><br><span class="line">@property(nonatomic,readonly)BOOL isBeingDebugged;</span><br><span class="line">判断是不是正在调试；</span><br><span class="line"></span><br><span class="line">+ (BOOL)isAppExtension;</span><br><span class="line">如果是APPExtension就返回YES；</span><br><span class="line"></span><br><span class="line">+ (nullabel UIApplication *)sharedExtensionApplication;</span><br><span class="line">与shareApplication相同，但在APP Extension中返回你nil；</span><br><span class="line"></span><br><span class="line">- (void)incrementNetworkActivityCount;</span><br><span class="line">增加活动网络请求的数量，如果此数字在增量之前为0，则会启动状态栏网络活动指示器的动画，这个方法是线程安全的。并对APP Extension没有影响；</span><br><span class="line"></span><br><span class="line">- (void)decrementNetworkActivityCount;</span><br><span class="line">减少活动网络请求的数量。如果此数字在递减后变为0，则会停止为状态栏网络活动指示器设置动画，这个方法是线程安全的，并对APP Extension没有影响；</span><br></pre></td></tr></table></figure></p>
<p>#pragma mark - NSTimer 分类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+ (NSTimer *)scaheduledTimerWithTimeinterval:(NSTimeInterval)seconds block:(void(^)(NSTimer *timer))block repeats:(BOOL)repeats;</span><br><span class="line">创建并返回一个NSTimer对象，并将它调度到default mode模式的runloop中；</span><br><span class="line"></span><br><span class="line">+ (NSTimer *)timerWithTimeInterval:(NSTimeInterval)seconds block:(void (^)(NSTimer *timer))block repeats:(BOOL)repeats;</span><br><span class="line">创建并返回一个NSTimer对象，这个方法和上面那个的区别就是这个需要自己放到runloop中；</span><br></pre></td></tr></table></figure></p>
<p>#pragma mark - NSParagraphStyle 分类<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+ (nullable NSParagraphStyle *)styleWithCTStyle:(CTParagraphStyleRef)CTStyle;</span><br><span class="line">根据CTParagraphStyleRef创建新的NSParagraphStyle对象；</span><br></pre></td></tr></table></figure></p>
<p>#pragma mark - NSObject 分类 之YYModel<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">如果默认的模型转换不能适合你的模型类，实现协议中的一个或者更多的方法来改变默认的键值转换过程，不用在你的类的头文件中添加&lt;YYModel&gt;；</span><br><span class="line">+ (nullable NSDictionary&lt;NSString *,id&gt; *)modelCustomPropertyMapper;</span><br><span class="line">如果JSON/NSDictionary中的key不能匹配模型中属性的名字，实现这个方法并返回映射；</span><br><span class="line"></span><br><span class="line">+ (nullable NSDictionary&lt;NSString *,id&gt; *)modelContainerPropertyGenericClass;</span><br><span class="line">容器属性的泛型类映射器。如NSArray，NSSet，NSDictionary，实现此方法并返回一个property-》class映射器，告诉哪种对象将被添加到array，set，dictionary。</span><br><span class="line"></span><br><span class="line">+ (nullable Class)modelCustomClassForDictionary:(NSDictionary *)dictionary;</span><br><span class="line">如果你需要在json-》Object转换过程中创建不同类的示例，使用该方法根据字典数据选择自定义类；</span><br><span class="line"></span><br><span class="line">+ (nullable NSArray&lt;NSString *&gt; *)modelPropertyBlacklist;</span><br><span class="line">在模型转换过程中，所有黑名单中的属性将被忽略，返回值就是一组属性名称；</span><br><span class="line"></span><br><span class="line">+ (nullabel NSArray&lt;NSString *&gt; *)modelPropertyWhitelist;</span><br><span class="line">如果属性不在白名单中，它将在模型转换过程中被忽略。</span><br><span class="line"></span><br><span class="line">+ (nullable NSArray *)modelArrayWithClass:(Class)cls json:(id)json;</span><br><span class="line">从json-array创建并返回一个数组；</span><br><span class="line"></span><br><span class="line">+ (nullabel NSDictionary *)modelDictionaryWithClass:(Class)cls json:(id)json;</span><br><span class="line">从json创建并返回一个字典；</span><br><span class="line"></span><br><span class="line">+ (nullabel instancetype)modelWithJson:(id)json;</span><br><span class="line">从json创建并返回一个实例，该方法是线程安全的；</span><br><span class="line"></span><br><span class="line">+ (nullable instancetype)modelWithDictionary:(NSDictionary *)dictionary;</span><br><span class="line">从字典创建并返回一个实例，该方法是线程安全的；这里注意，在给对象的属性进行赋值的时候，如果值类型和属性类型不符合的话，该方法会按照下面规则进行适当的转换；</span><br><span class="line">`NSString` or `NSNumber` -&gt; c number, such as BOOL, int, long, float, NSUInteger...</span><br><span class="line">`NSString` -&gt; NSDate, parsed with format &quot;yyyy-MM-dd&apos;T&apos;HH:mm:ssZ&quot;, &quot;yyyy-MM-dd HH:mm:ss&quot; or &quot;yyyy-MM-dd&quot;.</span><br><span class="line">`NSString` -&gt; NSURL.</span><br><span class="line">`NSValue` -&gt; struct or union, such as CGRect, CGSize, ...</span><br><span class="line">`NSString` -&gt; SEL, Class.</span><br><span class="line"></span><br><span class="line">- (BOOL)modelSetWithJSON:(id)json;</span><br><span class="line">判断model和json之间的转换是否成功；</span><br><span class="line"></span><br><span class="line">- (BOOL)modelSetWithDictionary:(NSDictionary *)dic;</span><br><span class="line">用给定的字典设置接受者的属性；字典中的key会映射到接受者的属性名称上，值将被设置给属性，如果值类型和属性类型不相符，这个方法将会按照下面的规则进行转换；</span><br><span class="line">`NSString` or `NSNumber` -&gt; c number, such as BOOL, int, long, float, NSUInteger...</span><br><span class="line">`NSString` -&gt; NSDate, parsed with format &quot;yyyy-MM-dd&apos;T&apos;HH:mm:ssZ&quot;, &quot;yyyy-MM-dd HH:mm:ss&quot; or &quot;yyyy-MM-dd&quot;.</span><br><span class="line">`NSString` -&gt; NSURL.</span><br><span class="line">`NSValue` -&gt; struct or union, such as CGRect, CGSize, ...</span><br><span class="line">`NSString` -&gt; SEL, Class.</span><br><span class="line"></span><br><span class="line">- (nullable id)modelToJSONObject;</span><br><span class="line">根据接受者属性生成一个json对象；如果接受者是NSArray，NSDictionary or NSSet，那么它仅将内部对象转化为json对象；</span><br><span class="line"></span><br><span class="line">- (nullabel NSData *)modelToJSONData;</span><br><span class="line">根据接受者属性生成一个json data；如果接受者是NSArray，NSDictionary，NSSet，那么它仅将内部对象转化为json字符串；</span><br><span class="line"></span><br><span class="line">- (nullabel NSString *)modelToJSONString;</span><br><span class="line">根据接受者属性，生成一个json字符串；</span><br><span class="line"></span><br><span class="line">- (nullable id)modelCopy;</span><br><span class="line">根据接受者属性，生成一个实例；</span><br><span class="line"></span><br><span class="line">- (void)modelEncodeWithCoder:(NSCoder *)aCoder;</span><br><span class="line">将接受者属性编码到coder；</span><br><span class="line"></span><br><span class="line">- (id)modelInitWithCoder:(NSCoder *)aDecoder;</span><br><span class="line">将接受者属性进行解码；</span><br><span class="line"></span><br><span class="line">- (NSUInteger)modelHash;</span><br><span class="line">获取接受者属性的hash code；</span><br><span class="line"></span><br><span class="line">- (NSString *)modelDescription;</span><br><span class="line">返回接受者内容的描述字符串；</span><br></pre></td></tr></table></figure></p>
<p>#pragma mark - NSObject 分类 之 KVO<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (void)addObserverBlockForKeyPath:(NSString *)keyPath block:(void(^)(id _Nonnull obj,_Nullable id oldVal,_Nullable id newVal))block;</span><br><span class="line">该方法的作用就是根据接受者指定的key-path注册block接收KVO通知；block和block捕获的对象都被引用，调用removeObserverBlocksForKeyPath：或者removeObserverBlocks进行释放；block：注册KVO通知的block；</span><br><span class="line"></span><br><span class="line">- (void)removeObserverBlocksForKeyPath:(NSString *)keyPath;</span><br><span class="line">对于指定的key-path指定的属性，停止所有接收改变的通知的所有block（通过addObserverBlockForKeyPath：block：指派）；</span><br><span class="line"></span><br><span class="line">- (void)removeObserverBlocks;</span><br><span class="line">停止所有的block（由addObserverBlockForKeyPath：block：指派）接收更改的通知，并释放这些block；</span><br></pre></td></tr></table></figure></p>
<p>#pragma mark - NSObject 分类 之 Sending messages with variable parameters<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">框架结构;Sending messages with variable parameters（可变变量）,swap method(交换方法)，Associate value(关联属性)</span><br><span class="line"> </span><br><span class="line"> - (nullable id)performSelectorWithArgs:(SEL)sel,...;</span><br><span class="line"> 想receiver发送指定的消息，并返回消息的结果；</span><br><span class="line"> sel：一个标识要发送消息的selector，如果selector是NULL或者不识别的，会抛出NSInvalidArgumentException；</span><br><span class="line"> ...：变量参数列表，参数类型必须和selector方法声明的类型一致，否则可能导致不期望的错误，它不支持大于256bytes的union或者struct。</span><br><span class="line"> 如果selector的返回类型不是对象，selector的返回值将被包装为NSNumber or NSValue；如果selector的返回类型是void那么就会返回nil；</span><br><span class="line"> 列：</span><br><span class="line"></span><br><span class="line"> NSData *data = [NSData dataWithContentsOfURL:[NSURL URLWithString:testURL()]];</span><br><span class="line"> UIImage *image = [UIImage.class performSelectorWithArgs:@selector(imageWithData:scale:),data,2.0];</span><br><span class="line"> UIImage *image1 = [UIImage imageWithData:data scale:2.0];</span><br><span class="line"> 这两个方法是一样的意思：</span><br><span class="line"> 区别：调用路径不一样：performSelector 先去寻找对应IMP，速度更快，不过写法变得相对没有那么安全；直接调用，走runtime；</span><br><span class="line"> </span><br><span class="line"> - (void)performSelectorWithArgs:(SEL)sel afterDelay:(NSTimeInterval)delay,...;</span><br><span class="line"> 延迟一定时间后，使用默认模式在当前线程上调用receiver的方法；</span><br><span class="line"> 注意：不能通过先前的request取消；</span><br><span class="line"> sel：一个指定要发送消息的selector，如果selector是NULL或者无法识别，那么就会引起错误NSInvalidArgumentException。</span><br><span class="line"> delay：在消息被发出前的最小时间，指定为0并不能保证立即执行，selector仍然会在线程run loop中进行排队，并会尽快执行；</span><br><span class="line"> ...：变量参数列表，参数类型必须和selector方法声明类型一致，否则会引起无法预期的错误，不支持大于256 bytes的union或者struct。</span><br><span class="line"> </span><br><span class="line"> - (nullable id)performSelectorWithArgsOnMainThread:(SEL)sel waitUntilDone:(BOOL)wait,...;</span><br><span class="line"> 使用default mode 在主线程中调用receiver的方法；</span><br><span class="line"> wait：一个BOOL值，指定当前线程是否阻塞直到在指定的线程执行完指定的selector，指定为YES阻塞这个线程，否则表示立即返回；如果selector的返回类型不是对象，那么返回结果被包装为NSNumber or NSValue，如果selector的返回类型是void，那么wait就是YES。</span><br></pre></td></tr></table></figure></p>
<p>#pragma mark - NSObject分类之Swap method (Swizzling)<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">埋点统计，基类，有点类似服务器端的域名重定向；</span><br><span class="line"></span><br><span class="line">+ (BOOL)swizzleInstanceMethod:(SEL)originalSel with:(SEL)newSel;</span><br><span class="line">交换一个类中两个对象方法：</span><br><span class="line"></span><br><span class="line">+ (BOOL)swizzleClassMethod:(SEL)orginalSel with:(SEL)newSel;</span><br><span class="line">交换一个类中的了两个类方法。</span><br></pre></td></tr></table></figure></p>
<p>#pragma mark - NSObject分类之 Associate Value<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">- (void)setAssociateValue:(nullable id)value withKey:(void *)key;</span><br><span class="line">将self和一个对象关联，起到类似strong修饰的属性的作用；动态增加对象属性并赋值，取值时也要用动态取值getAssociatedValueForKey:方法；</span><br><span class="line"></span><br><span class="line"> - (void)setAssociateWeakValue:(nullable id)value withKey:(void *)key;</span><br><span class="line">动态增加对象属性并赋值，起到类似weak修饰的属性的作用。</span><br><span class="line"></span><br><span class="line">- (void)removeAssociatedValues;</span><br><span class="line">移除所有关联的值。</span><br><span class="line"></span><br><span class="line">UIFont *font = [[UIFont alloc]init];</span><br><span class="line">id font1 = [font deepCopy];</span><br><span class="line">[font setAssociateValue:@&quot;asso&quot; withKey:@&quot;fontName&quot;];</span><br><span class="line">NSLog(@&quot;fontName: %@&quot;,[font getAssociatedValueForKey:@&quot;fontName&quot;]);</span><br><span class="line">[font setAssociateWeakValue:@&quot;14&quot; withKey:@&quot;fontSize&quot;];</span><br><span class="line">[font getAssociatedValueForKey:@&quot;fontSize&quot;];</span><br><span class="line">[font removeAssociatedValues];</span><br><span class="line"></span><br><span class="line">BillHomeModel *model = [[BillHomeModel alloc]init];</span><br><span class="line">model.name = @&quot;lily&quot;;</span><br><span class="line">model.imageURL = testURL();</span><br><span class="line">[model addObserverBlockForKeyPath:@&quot;name&quot; block:^(id  _Nonnull obj, id  _Nullable oldVal, id  _Nullable newVal) &#123;</span><br><span class="line">NSLog(@&quot;obj:%@---old:%@----new:%@&quot;,obj,oldVal,newVal);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[model setAssociateValue:@&quot;qian&quot; withKey:@&quot;asso&quot;];</span><br><span class="line">[model getAssociatedValueForKey:@&quot;asso&quot;]&apos;</span><br><span class="line">model.name = @&quot;Josh&quot;;</span><br><span class="line">model.name = @&quot;Bella&quot;;</span><br><span class="line">[model removeObserverBlocksForKeyPath:@&quot;name&quot;];</span><br><span class="line">[model removeObserverBlocks];</span><br></pre></td></tr></table></figure></p>
<p>#pragma mark - NSObject分类之 Other<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+ (NSString *)className;</span><br><span class="line">返回类名的NSString形式；</span><br><span class="line"></span><br><span class="line">- (NSString *)className;</span><br><span class="line">返回类名的NSString形式；</span><br><span class="line"></span><br><span class="line">- (nullable id)deepCopy;</span><br><span class="line">返回NSKeyedArchiver 和 NSKeyedUnarchiver示例对象的副本；</span><br><span class="line">深拷贝是指将整个对象内存直接拷贝到另一块内存中，浅拷贝（shallow copy）仅仅拷贝指向对象的指针，即浅拷贝是指针拷贝，深拷贝是内容拷贝，实现深拷贝的方法，可以先将对象归档后再进行解档，通过归档后解档获取内容一致的集合，并且该集合又存在另一块内存上，互不影响。</span><br></pre></td></tr></table></figure></p>
<p>#pragma mark - NSNotificationCenter 分类<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (void)postNotificationOnMainThread:(NSNotification *)notification;</span><br><span class="line">在主线程中发送通知，如果当前线程是主线程，那么就同步发送通知，如果当前线程不是主线程，异步发送通知；</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>#pragma mark - NSKeyedUnarchiver 分类<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (nullable id)unarchiveObjectWithData:(NSData *)</span><br></pre></td></tr></table></figure></p>
<p>#pragma mark - NSDictionary 分类 之 dictionary convertor（转化器）<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">NSDictionary框架结构：Dictionary convertor，dictionary value center，NSMutableDictionary；</span><br><span class="line">+ (nullable NSDictionary *)dictionaryWithPlistData:(NSData *)plist;</span><br><span class="line">将指定的plist数据转化为一个字典；</span><br><span class="line"></span><br><span class="line">+ (nullable NSDictionary *)dictionaryWithPlistStirng:(NSString *)plist;</span><br><span class="line">将指定的property list xml 字符串转化为一个字典；</span><br><span class="line"></span><br><span class="line">- (nullable NSData *)plistData;</span><br><span class="line">将字典序列化一个binary property list data；</span><br><span class="line"></span><br><span class="line">- (nullable NSString *)plistString;</span><br><span class="line">将字典序列化一个xml property list 字符串；</span><br><span class="line"></span><br><span class="line">- (NSArray *)allKeysSorted;</span><br><span class="line">将字典的所有key查出来，并且在数组中按照升序进行排列,key必须是NSString类型的；</span><br><span class="line"></span><br><span class="line">- (NSArray *)allValuesSortedByKeys;</span><br><span class="line">返回key对应的值，并数组中的值是按找keys的升序排列的；</span><br><span class="line"></span><br><span class="line">- (BOOL)containsObjectForKey:(id)key;</span><br><span class="line">判断字典是否有指定key对应的value。</span><br><span class="line"></span><br><span class="line">- (NSDictionary *)entriesForKeys:(NSArray *)keys;</span><br><span class="line">返回keys对应的新的字典: 查找keys对应的values，并将这些keys和values组装成新的字典；</span><br><span class="line"></span><br><span class="line">- (nullable NSString *)jsonStringEncoded;</span><br><span class="line">将字典转化为json字符串；</span><br><span class="line"></span><br><span class="line">- (nullable NSString *)jsonPrettyStringEncoded;</span><br><span class="line">将字典转化为json字符串格式；</span><br><span class="line"></span><br><span class="line">+ (nullable NSDictionary *)dictionaryWithXML:(id)xmlDataOrString;</span><br><span class="line">尝试解析xml并将其包装到字典中，如果你只是想从一个小的xml获取一些价值，试试这个方法；</span><br><span class="line"></span><br><span class="line">NSString *path = [[NSBundle mainBundle] pathForResource:@&quot;YYKPlist&quot; ofType:@&quot;plist&quot;];</span><br><span class="line">NSData *plistD = [NSData dataWithContentsOfFile:path];</span><br><span class="line">NSDictionary *dic = [NSDictionary dictionaryWithPlistData:plistD];</span><br><span class="line">NSDictionary *xmlD = [NSDictionary dictionaryWithPlistString:[self xmlString]];</span><br><span class="line">NSData *data = [dic plistData];</span><br><span class="line">NSString *xmlString = [xmlD plistString];</span><br><span class="line">NSArray *keys = [dic allKeysSorted];</span><br><span class="line">NSArray *values = [dic allValuesSortedByKeys];</span><br><span class="line">BOOL isAge = [dic containsObjectForKey:@&quot;age&quot;];</span><br><span class="line">NSDictionary *newDic = [dic entriesForKeys:@[@&quot;age&quot;,@&quot;weight&quot;]];</span><br><span class="line">NSString *jsonString = [dic jsonStringEncoded];</span><br><span class="line">NSString *prettyJson = [dic jsonPrettyStringEncoded];</span><br><span class="line">NSDictionary *xmlDic = [NSDictionary dictionaryWithXML:[self xmlString]];</span><br><span class="line"></span><br><span class="line">NSMutableDictionary *muDic = [NSMutableDictionary dictionaryWithPlistData:plistD];</span><br><span class="line">NSMutableDictionary *xmlMuDic = [NSMutableDictionary dictionaryWithPlistString:[self xmlString]];</span><br><span class="line">[muDic popObjectForKey:@&quot;age&quot;];</span><br><span class="line">[muDic popEntriesForKeys:@[@&quot;age&quot;,@&quot;eat&quot;]];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">NSLog(@&quot;%@&quot;,xmlD);</span><br></pre></td></tr></table></figure></p>
<p>#pragma mark - NSDictionary 分类 之 dictionary value getter<br>    /*</p>
<pre><code>*/
</code></pre><p>#pragma mark - NSDictionary 分类 之 dictionary NSMutableDictionary<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+ (nullable NSMutableDictionary *)dictionaryWithPlistData:(NSData *)plist;</span><br><span class="line">根据指定的property list data 创建并返回一个字典；</span><br><span class="line"></span><br><span class="line">+ (nullable NSMutableDictionary *)dictionaryWithPlistString:(NSSting *)plist;</span><br><span class="line">根据指定的property list xml 字符串创建并返回一个字典；</span><br><span class="line"></span><br><span class="line">- (nullable id)popObjectForKey:(id)aKey;</span><br><span class="line">移除字典中指定key对应的值,并将这个移除的value返回；</span><br><span class="line"></span><br><span class="line">- (NSDictionary *)popEntriesForKeys:(NSArray *)keys;</span><br><span class="line">移除字典中一组指定key对应的一组值，并将移除的值返回；</span><br></pre></td></tr></table></figure></p>
<p>#pragma mark - NSDate 分类 之 component properties<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">NSDate框架结构：Component Properties，Date Modify，Date format。</span><br><span class="line">NSDate *date = [NSDate date];</span><br><span class="line">NSInteger year = date.year;</span><br><span class="line">NSInteger month = date.month;</span><br><span class="line">NSInteger day = date.day;</span><br><span class="line">NSInteger hour = date.hour;</span><br><span class="line">NSInteger minute = date.minute;</span><br><span class="line">NSInteger second = date.second;</span><br><span class="line">NSInteger nanoSecond = date.nanosecond;</span><br><span class="line">NSInteger weekday = date.weekday;</span><br><span class="line">NSInteger weekdayOrdinal = date.weekdayOrdinal;</span><br><span class="line">NSInteger weekofmonth = date.weekOfMonth;</span><br><span class="line">NSInteger weekofyear = date.weekOfYear;</span><br><span class="line">NSInteger yearForWeekOfYear = date.yearForWeekOfYear;</span><br><span class="line">NSInteger quater = date.quarter;// 季度</span><br><span class="line">BOOL isLeapMonth = date.isLeapMonth;</span><br><span class="line">BOOL isLeapYear = date.isLeapYear;</span><br><span class="line">BOOL isToday = date.isToday;</span><br><span class="line">BOOL isYesterDay = date.isYesterday;</span><br></pre></td></tr></table></figure></p>
<p>#pragma mark - NSDate 分类 之 date modify<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">- (nullable NSDate *)dateByAddingYears:(NSInteger)years;</span><br><span class="line">在日期的基础上增加指定的年数；</span><br><span class="line"></span><br><span class="line">- (nullable NSDate *)dateByAddingMonths:(NSInteger)months;</span><br><span class="line">在日期的基础上增加指定的月数；</span><br><span class="line"></span><br><span class="line">- (nullable NSDate *)dateByAddingWeeks:(NSInteger)weeks;</span><br><span class="line">在日期的基础上增加指定的周数；</span><br><span class="line"></span><br><span class="line">- (nullable NSDate *)dateByAddingDays:(NSInteger)days;</span><br><span class="line">在日期的基础上增加指定的天数；</span><br><span class="line"></span><br><span class="line">- (nullable NSDate *)dateByAddingHours:(NSInteger)hours;</span><br><span class="line">在日期的基础上增加指定的小时数；</span><br><span class="line"></span><br><span class="line">- (nullable NSDate *)dateByAddingMinutes:(NSInteger)minutes;</span><br><span class="line">在日期的基础上增加指定的分钟数。</span><br><span class="line"></span><br><span class="line">- (nullable NSDate *)dateByAddingSeconds:(NSInteger)seconds;</span><br><span class="line">在日期的基础上增加指定的秒数。</span><br><span class="line"></span><br><span class="line">NSDate *date = [NSDate date];</span><br><span class="line">NSDate *date11 = [date dateByAddingYears:2];</span><br><span class="line">NSDate *date22 = [date dateByAddingMonths:2];</span><br><span class="line">NSDate *date33 = [date dateByAddingDays:2];</span><br><span class="line">NSDate *date44 = [date dateByAddingWeeks:2];</span><br><span class="line">NSDate *date55 = [date dateByAddingHours:2];</span><br><span class="line">NSDate *date66 = [date dateByAddingMinutes:2];</span><br><span class="line">NSDate *date77 = [date dateByAddingSeconds:2];</span><br></pre></td></tr></table></figure></p>
<p>#pragma mark - NSDate 分类 之 date format<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">- (nullable NSString *)stringWithFormat:(NSString *)format;</span><br><span class="line">返回一个代表日期的格式化字符串：这里用到了国际化作为大家都不常用的一个类，NSLocale类是将与国家和语言相关的信息进行简单的组合，包括货币，文学方面的信息。 货币：货币的国际名称（人民币的国际货币名称是CNY）；货币符号（人民币的国际货币符号是¥） 文学：标点符号，文字的书写顺序（左右顺序），引用的起止符号等等 若做金融一类的应用可能会用到NSLocale这个类。https://www.jianshu.com/p/81c5ff4edf32</span><br><span class="line"></span><br><span class="line">- (nullable NSString *)stringWithFormat:(NSString *)format timeZone:(nullable NSTimeZone *)timeZone locale:(nullable NSLocale *)locale;</span><br><span class="line">返回一个代表日期的格式化字符串:time 时区，local：国家信息的组合</span><br><span class="line"></span><br><span class="line">- (nullable NSString *)stringWithISOFormat;</span><br><span class="line">返回一个代表日期的ISO08601格式的字符串。</span><br><span class="line"></span><br><span class="line">+ (nullable NSDate *)dateWithString:(NSString *)dateString format:(NSString *)format;</span><br><span class="line">返回从使用格式解释的给定字符串解析的日期；</span><br><span class="line"></span><br><span class="line">+ (nullable NSDate *)dateWithString:(NSString *)dateString format:(NSString *)format timeZone:(nullable NSTimeZone *)timeZone locale:(nullable NSLocale *)locale;</span><br><span class="line">返回从使用格式解释的给定字符串解析的日期；</span><br><span class="line"></span><br><span class="line">+ (nullable NSDate *)dateWithISOFormatString:(NSString *)dateString;</span><br><span class="line">返回从使用ISO08601格式解释的给定字符串解析的日期；</span><br><span class="line"></span><br><span class="line">NSDate *date = [NSDate date];</span><br><span class="line">NSString *string = [date stringWithFormat:@&quot;yyyy-MM-dd HH:mm:ss&quot;];</span><br><span class="line">NSString *string11 = [date stringWithFormat:@&quot;yyyy-MM-dd HH:mm:ss&quot; timeZone:[NSTimeZone timeZoneWithName:@&quot;America/Chicago&quot;] locale:[NSLocale localeWithLocaleIdentifier:@&quot;en_US&quot;]];</span><br><span class="line">NSString *isoString = [date stringWithISOFormat];</span><br><span class="line">NSDate *date11 = [NSDate dateWithString:string format:@&quot;yyyy-MM-dd HH:mm:ss&quot;];</span><br><span class="line">NSDate *date22 = [NSDate dateWithString:string format:@&quot;yyyy-MM-dd HH:mm:ss&quot; timeZone:[NSTimeZone timeZoneWithName:@&quot;America/Chicago&quot;] locale:[NSLocale localeWithLocaleIdentifier:@&quot;en_US&quot;]];</span><br><span class="line">NSDate *date33 = [NSDate dateWithISOFormatString:isoString];</span><br></pre></td></tr></table></figure></p>
<p>#pragma mark - NSData 分类 之 Hash<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">NSData框架结构：Hash，Encrypt and decrypt，Encode and decode，inflate and deflate，others；</span><br><span class="line">- (NSString *)md2String;</span><br><span class="line"> 返回的是md2 hash小写字母字符串</span><br><span class="line"></span><br><span class="line">- (NSData *)md2Data;</span><br><span class="line">返回的是md2 hash的NSData对象；</span><br><span class="line"></span><br><span class="line">NSString *password = @&quot;123589632541125&quot;;</span><br><span class="line">NSString *md2 = [password md2String];</span><br><span class="line">NSString *md4 = [password md4String];</span><br><span class="line">NSString *md5 = [password md5String];</span><br><span class="line">NSString *sha1 = [password sha1String];</span><br><span class="line">NSString *sha224 = [password sha224String];</span><br><span class="line">NSString *sha256 = [password sha256String];</span><br><span class="line">NSString *sha384 = [password sha384String];</span><br><span class="line">NSString *sha512 = [password sha512String];</span><br><span class="line"></span><br><span class="line">NSString *salt = @&quot;salt&quot;;</span><br><span class="line">NSString *md5Salt = [password hmacMD5StringWithKey:salt];// 俗称加盐:返回的是md5和指定的key进行加密返回的小写字母字符串；</span><br><span class="line">NSString *sha1Salt = [password hmacSHA1StringWithKey:salt];</span><br><span class="line">NSString *sha224Salt = [password hmacSHA224StringWithKey:salt];</span><br><span class="line">NSString *sha256Salt = [password hmacSHA256StringWithKey:salt];</span><br><span class="line">NSString *sha384Salt = [password hmacSHA384StringWithKey:salt];</span><br><span class="line">NSString *sha512Salt = [password hmacSHA512StringWithKey:salt];</span><br><span class="line">NSString *crc32 = [password crc32String];</span><br></pre></td></tr></table></figure></p>
<p>#pragma mark - NSData 分类 之 Encrypt and Decrypt<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (nullable NSData *)aes256EncryptWithKey:(NSData *)key iv:(nullable NSData *)iv;</span><br><span class="line">返回一个使用AES加密的NSData数据</span><br><span class="line">key：一个长度为16，24，32，128，192或者256位的key；</span><br><span class="line">iv：一个初始化长度为16（128位）的向量，如果不想使用iv就穿nil；</span><br><span class="line"></span><br><span class="line">- (nullable NSData *)aes256DecryptWithKey:(NSData *)key iv:(nullable NSData *)iv;</span><br><span class="line">返回使用AES进行解密的NSData数据；</span><br></pre></td></tr></table></figure></p>
<p>#pragma mark - NSData 分类 之 Encode and Decode<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NSData *data = [@&quot;可爱的人&quot; dataUsingEncoding:NSUTF8StringEncoding];</span><br><span class="line">NSString *string = [data utf8String];</span><br><span class="line">NSString *hexS = [data hexString];// 返回大写的十六进制字符串</span><br><span class="line">NSData *hexData = [NSData dataWithHexString:hexS];// 根据十六进制的字符串返回NSData数据；</span><br><span class="line">NSString *base64 = [data base64EncodedString];</span><br><span class="line">NSData *baseData = [NSData dataWithBase64EncodedString:base64];</span><br><span class="line">id value = [baseData jsonValueDecoded];// 对自己进行解码并返回NSDictionary或NSArray对象；</span><br></pre></td></tr></table></figure></p>
<p>#pragma mark - NSData 分类 之 Inflate and deflate(压缩和解压缩)<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Content-Encoding 的取值有 gzip、defalte、compress、identity、br 等，具体用到哪个需要跟服务端协商好。Xcode 提供的 zlib 可以实现这里的 gzip、defalte 这两种编码格式。</span><br><span class="line">gzip</span><br><span class="line">一种由文件压缩程序「Gzip，GUN zip」产生的编码格式，描述于 RFC 1952。这种编码格式是一种具有 32 位 CRC 的 Lempel-Ziv 编码（LZ77）；</span><br><span class="line">deflate</span><br><span class="line">由定义于 RFC 1950 的「ZLIB」编码格式与 RFC 1951 中描述的「DEFLATE」压缩机制组合而成的产物；</span><br><span class="line">由于 HTTP 1.1 的命名失误，deflate 当初应该命名为 zlib，因为其本身就是使用 zlib 格式编码，用 deflate 造成了与 DEFLATE 算法的混淆，事实上 Content-Encoding 为 gzip 和 deflate 时都可能使用 DEFLATE 算法。</span><br><span class="line"></span><br><span class="line">iOS开发中看，应用大多以XML或json的格式传输数据的，并且XML和JSON通常会比较大，所以客户端需要用下载或者上传的时间会比较长，这时我们可以考虑压缩数据，Gzip是一种比zip更优的压缩技术，它可以将数据压缩到60%，因此对客户端和服务器端来说就更加轻量级了。</span><br><span class="line">Gzip的优点：降低客户端对数据的下载时间和上传时间；节省流量；</span><br><span class="line"></span><br><span class="line">- (nullable NSData *)gzipInflate; 从gzip数据解压数据</span><br><span class="line">- (nullable NSData *)gzipDefalte; 根据默认的压缩级别，将数据压缩到gzip</span><br><span class="line">- (nullable NSData *)zlibInflate; 从zlib-compress数据解压缩数据</span><br><span class="line">- (nullable NSData *)zlibDeflate; 以默认的压缩级别将数据压缩为zlib0compressed；</span><br></pre></td></tr></table></figure></p>
<p>#pragma mark - NSData 分类 之 Others<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+ (nullable NSData *)dataNamed:(NSString *)name;</span><br><span class="line">从main bundle 中的文件(这里的文件不能有后缀名)中创建data数据，类似于[UIImage imageNamed:]</span><br><span class="line"></span><br><span class="line">NSString *path = [[NSBundle mainBundle] pathForResource:@&quot;comment&quot; ofType:@&quot;jpeg&quot;];</span><br><span class="line">NSData *imageD = [NSData dataWithContentsOfFile:path];</span><br><span class="line">NSData *data = [NSData dataNamed:@&quot;File&quot;];</span><br></pre></td></tr></table></figure></p>
<p>{</p>
<p>#pragma mark - NSBundle 分类<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+ (NSArray&lt;NSNumber *&gt; *)preferredScales;</span><br><span class="line">获取一个NSNumber数组，展示path scale搜索下的最好顺序；</span><br><span class="line"></span><br><span class="line">+ (nullable NSString *)pathForScaledResource:(NSString *)name ofType:(nullable NSString *)ext inDirectory:(NSString *)bundlePath;</span><br><span class="line">返回由指定名称和扩展名标识的资源文件的完成路径名，并位于给定的捆绑目录中。它首先用当前屏幕的比例（例如@2x）搜索文件，然后从较高比例搜索到较低比例；</span><br><span class="line">bundlePath：要搜索的文件的上一级目录路径；</span><br><span class="line">return：资源文件的全路径，如果文件找不到就返回nil，如果bundlepath参数指定的bundle不存在或者是不可读的目录，也会返回nil；</span><br><span class="line">ext：如果extension是一个空的字符串或者nil，那么extension就假设不存在，文件就是第一个和名字匹配的那个。</span><br><span class="line"></span><br><span class="line">NSArray *scales = [NSBundle preferredScales];</span><br><span class="line">NSString *path = [NSBundle pathForScaledResource:@&quot;comment&quot; ofType:@&quot;jpeg&quot; inDirectory:@&quot;/Users/aker/work/MyLessonDemo2019/MyLessonDemo2019&quot;];</span><br><span class="line">NSString *path1 = [[NSBundle mainBundle] pathForScaledResource:@&quot;comment&quot; ofType:@&quot;jpeg&quot;];</span><br><span class="line">NSString *path2 = [[NSBundle mainBundle] pathForScaledResource:@&quot;comment&quot; ofType:@&quot;jpeg&quot; inDirectory:@&quot;/Users/aker/work/MyLessonDemo2019/MyLessonDemo2019&quot;];</span><br></pre></td></tr></table></figure></p>
<p>#pragma mark - NSAttributedString 分类<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">框架结构：</span><br><span class="line">基本，get YYText attribute as property，query for YYText，create attachment string for YYText，Utility，set character attribute，set character attribute as property，set paragraph attribute as property，set YYText attribute as property，set discontinuous attribute for range，convenience methods for text highlight，utilities，get paragraph attribute as property，get character attribute as property，retrieving character attribute Information；</span><br><span class="line"></span><br><span class="line">- (nullable NSData *)archiveToData;</span><br><span class="line">将字符串归档到数据库；</span><br><span class="line"></span><br><span class="line">+ (nullable instancetype)unarchiveFromData:(NSData *)data;</span><br><span class="line">从数据中接档出字符串；</span><br><span class="line"></span><br><span class="line">NSAttributedString *att = [[NSAttributedString alloc]initWithString:@&quot;这是一个空白页面&quot; attributes:@&#123;NSForegroundColorAttributeName:[UIColor blackColor],NSFontAttributeName:[UIFont systemFontOfSize:20 weight:UIFontWeightBold]&#125;];</span><br><span class="line">NSData *data = [att archiveToData];</span><br><span class="line">NSAttributedString *attr = [NSAttributedString unarchiveFromData:data];</span><br></pre></td></tr></table></figure></p>
<p>#pragma mark - NSAttributedString 分类 Retrieving character attribute information（检索字符串属性信息）<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@property (nullable, nonatomic, copy, readonly) NSDictionary&lt;NSString *, id&gt; *attributes;</span><br><span class="line">返回第一个字符的属性。</span><br><span class="line"></span><br><span class="line">- (nullable NSDictionary&lt;NSString *, id&gt; *)attributesAtIndex:(NSUInteger)index;</span><br><span class="line">返回给定索引的字符的属性，如果索引位于接收者字符的末尾，那么就会引起NSRangeException错误；</span><br><span class="line"></span><br><span class="line">- (nullable id)attribute:(NSString *)attributeName atIndex:(NSUInteger)index;</span><br><span class="line">给定索引给定字符名的属性的值；</span><br></pre></td></tr></table></figure></p>
<p>#pragma mark - NSAttributedString 分类  其他部分<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">NSAttributedString *att = [[NSAttributedString alloc]initWithString:@&quot;这是一个空白页面&quot; attributes:@&#123;NSForegroundColorAttributeName:[UIColor blackColor],NSFontAttributeName:[UIFont systemFontOfSize:20 weight:UIFontWeightBold]&#125;];</span><br><span class="line">NSData *data = [att archiveToData];</span><br><span class="line">NSAttributedString *attr = [NSAttributedString unarchiveFromData:data];</span><br><span class="line">NSDictionary *attribute = att.attributes;</span><br><span class="line">NSDictionary *attribute111 = [att attributesAtIndex:5];</span><br><span class="line">id atttribute444 = [att attribute:NSForegroundColorAttributeName atIndex:1];</span><br><span class="line">UIFont *font = att.font;</span><br><span class="line">UIFont *font1 = [att fontAtIndex:2];</span><br><span class="line">NSString *plainT = [att plainTextForRange:NSMakeRange(0, 5)];</span><br></pre></td></tr></table></figure></p>
<h4 id="富文本的简单demo"><a href="#富文本的简单demo" class="headerlink" title="富文本的简单demo"></a>富文本的简单demo</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">     YYLabel *attLabel = [[YYLabel alloc]initWithFrame:CGRectMake(0, 0, kScreenWidthForApp(), 300)];</span><br><span class="line">     attLabel.backgroundColor = kLightMintColor();</span><br><span class="line">     attLabel.font = [UIFont systemFontOfSize:20 weight:UIFontWeightHeavy];</span><br><span class="line">     [self.view addSubview:attLabel];</span><br><span class="line">     NSMutableAttributedString *att = [[NSMutableAttributedString alloc]initWithString:@&quot;这是一个YYText小呆毛&quot; attributes:@&#123;NSForegroundColorAttributeName:kTitleColor,NSFontAttributeName:[UIFont systemFontOfSize:15 weight:UIFontWeightRegular]&#125;];</span><br><span class="line">     </span><br><span class="line">   //  content：附件（UIImage，UIView，CALayer）</span><br><span class="line">   //  contentMode：附件的内容模式</span><br><span class="line">   //  width：布局中附加内容的宽</span><br><span class="line">   //  ascent：布局中附件内容的ascent（这个值就是把图片转化为字符时要展示的字符大小）</span><br><span class="line">   //  descent：布局中附件内容的descent（这个值就是把图片转化为字符时要展示的字符大小）</span><br><span class="line">    NSMutableAttributedString *attach = [NSMutableAttributedString attachmentStringWithContent:[UIImage imageNamed:@&quot;test&quot;] contentMode:UIViewContentModeScaleAspectFit width:100 ascent:20 descent:20];</span><br><span class="line">    </span><br><span class="line">    // 图片</span><br><span class="line">    NSMutableAttributedString *attach11 = [NSMutableAttributedString attachmentStringWithContent:[UIImage imageNamed:@&quot;icon2019&quot;] contentMode:UIViewContentModeScaleAspectFit attachmentSize:CGSizeMake(50, 50) alignToFont:[UIFont systemFontOfSize:15 weight:UIFontWeightRegular] alignment:YYTextVerticalAlignmentCenter];</span><br><span class="line">    </span><br><span class="line">    // 从foursquare图像创建并返回附件，就好像它是表情符号emoji一样</span><br><span class="line">    NSMutableAttributedString *attach3 = [NSMutableAttributedString attachmentStringWithEmojiImage:[UIImage imageNamed:@&quot;MoreBill&quot;] fontSize:15];</span><br><span class="line">    </span><br><span class="line">    // gif 表情符号</span><br><span class="line">    NSString *path = [[NSBundle mainBundle] pathForResource:@&quot;tenor&quot; ofType:@&quot;gif&quot;];</span><br><span class="line">    NSData *imageD = [NSData dataWithContentsOfFile:path];</span><br><span class="line">    UIImage *aniImage = [UIImage sd_animatedGIFWithData:imageD];</span><br><span class="line">    NSMutableAttributedString *aniAttach = [NSMutableAttributedString attachmentStringWithEmojiImage:aniImage fontSize:50];</span><br><span class="line">    </span><br><span class="line">    [att appendAttributedString:attach];</span><br><span class="line">    [att appendAttributedString:attach11];</span><br><span class="line">    [att insertAttributedString:attach3 atIndex:0];</span><br><span class="line">    [att appendAttributedString:aniAttach];</span><br><span class="line">    </span><br><span class="line">    attLabel.attributedText = att;</span><br><span class="line"></span><br><span class="line">// Utility</span><br><span class="line">     - (NSRange)rangeOfAll;</span><br><span class="line">     返回长度区间</span><br><span class="line">     </span><br><span class="line">     - (BOOL)isShareAttributesInAllRanges;</span><br><span class="line">     如果是YES，它在整个文本范围内共享相同的属性；</span><br><span class="line">     </span><br><span class="line">     - (BOOL)canDrawWithUIKit;</span><br><span class="line">     如果是YES，则可以使用[drawWithRect：options：context：]方法绘制或使用UIKit显示。如果NO，则应使用CoreText或YYText进行绘制；</span><br><span class="line">     如果方法返回NO，则意味着至少有一个属性不受UIKit支持（如CTParagraphStyleRef）。如果在UIKit中显示此字符串，它可能会丢失一些属性，甚至导致应用程序崩溃；</span><br></pre></td></tr></table></figure>
<p>#pragma mark - NSMutableAttributedString分类<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">- (void)setAttributes:(nullable NSDictionary&lt;NSString *,id&gt; *)attributes;</span><br><span class="line">为整个字符串设置属性，旧的属性将被移除；attributes如果为nil表示移除所有属性；</span><br><span class="line"></span><br><span class="line">- (void)removeAttributesInRange:(NSRange)range;</span><br><span class="line">为字符串指定区间移除所有属性</span><br><span class="line"></span><br><span class="line">YYLabel *label2 = [[YYLabel alloc]initWithFrame:CGRectMake(0, 120 + kTopHeight(), kScreenWidthForApp(), 100)];</span><br><span class="line">label2.backgroundColor = [UIColor whiteColor];</span><br><span class="line">[self.view addSubview:label2];</span><br><span class="line"></span><br><span class="line">NSMutableAttributedString *label2Att = [[NSMutableAttributedString alloc]initWithString:@&quot;NSMutableAttributedString&quot; attributes:@&#123;NSForegroundColorAttributeName:kTitleColor,NSFontAttributeName:[UIFont boldSystemFontOfSize:20]&#125;];</span><br><span class="line"></span><br><span class="line">attach11.textShadow = [YYTextShadow shadowWithColor:[UIColor redColor] offset:CGSizeMake(5, 5) radius:0];</span><br><span class="line">//     文字阴影，只有字符可以，attachment设置没有效果；</span><br><span class="line">att.textShadow = [YYTextShadow shadowWithColor:[UIColor redColor] offset:CGSizeMake(20, 20) radius:0];// 外阴影</span><br><span class="line">att.textInnerShadow = [YYTextShadow shadowWithColor:[UIColor redColor] offset:CGSizeMake(5, 5) radius:0];// 内阴影</span><br><span class="line">YYTextDecoration * dec = [YYTextDecoration decorationWithStyle:YYTextLineStylePatternCircleDot width:[NSNumber numberWithFloat:100] color:kLightOrangeColor()];</span><br><span class="line">//    label2Att.textUnderline = dec;</span><br><span class="line"></span><br><span class="line">[label2Att setTextUnderline:dec range:NSMakeRange(0, label2Att.length)];</span><br><span class="line"></span><br><span class="line">// 设置点击事件</span><br><span class="line">[label2Att setTextHighlightRange:NSMakeRange(0, label2Att.length/2) color:[UIColor orangeColor] backgroundColor:[UIColor yellowColor] userInfo:@&#123;@&quot;label&quot;:@&quot;label2Att&quot;&#125; tapAction:^(UIView * _Nonnull containerView, NSAttributedString * _Nonnull text, NSRange range, CGRect rect) &#123;</span><br><span class="line">NSLog(@&quot;🍄---🍄---🍄---🍄---🍄---🍄---&quot;);</span><br><span class="line">&#125; longPressAction:^(UIView * _Nonnull containerView, NSAttributedString * _Nonnull text, NSRange range, CGRect rect) &#123;</span><br><span class="line">NSLog(@&quot;🌹----🌹----🌹----🌹----🌹----&quot;);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[label2Att insertString:@&quot;label  &quot; atIndex:0];</span><br><span class="line">[label2Att appendString:@&quot;fjajgla&quot;];</span><br></pre></td></tr></table></figure></p>
<p>#pragma mark - NSArray<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">NSString *path = [[NSBundle mainBundle] pathForResource:@&quot;array&quot; ofType:@&quot;plist&quot;];</span><br><span class="line">NSData *data = [NSData dataWithContentsOfFile:path];</span><br><span class="line">NSArray *array = [NSArray arrayWithPlistData:data];</span><br><span class="line">NSData *data1 = [array plistData];</span><br><span class="line">id object = [array randomObject];// 随机数</span><br><span class="line">[array objectOrNilAtIndex:2];// 返回某一index处的对象，索引越界就返回nil。类似ObjectAtIndex：但是不会抛出异常；</span><br><span class="line">NSString *json = [array jsonStringEncoded];// 将对象转化为json字符串，发生错误就返回nil</span><br><span class="line">NSString *jsonPre = [array jsonPrettyStringEncoded];// 将对象转化为json字符串formatted，如果发生错误就返回nil；</span><br><span class="line">NSLog(@&quot;json%@&quot;,json);</span><br><span class="line">NSLog(@&quot;jsonPre%@&quot;,jsonPre);</span><br></pre></td></tr></table></figure></p>
<p>#pragma mark - NSMuatableArray<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">NSString *path = [[NSBundle mainBundle] pathForResource:@&quot;array&quot; ofType:@&quot;plist&quot;];</span><br><span class="line">NSData *data = [NSData dataWithContentsOfFile:path];</span><br><span class="line">NSMutableArray *array = [NSMutableArray arrayWithPlistData:data];</span><br><span class="line">[array removeFirstObject];</span><br><span class="line">[array removeLastObject];</span><br><span class="line">[array insertObjects:array atIndex:0];</span><br><span class="line">[array reverse];// 将数组中的元素进行反向排序；</span><br><span class="line">[array shuffle];// 对这个数组中的对象进行随机排序；</span><br></pre></td></tr></table></figure></p>
<p>#pragma mark - MKAnnotationView 分类<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// mapview</span><br><span class="line">MKAnnotationView *ano = [[MKAnnotationView alloc]initWithFrame:CGRectMake(16, 300, kScreenWidthForApp() - 32, 300)];</span><br><span class="line">ano.imageURL = [NSURL URLWithString:testURL()];// 为此属性设置一个新值将取消先前的请求操作并创建一个新的请求操作来获取图像。设置为nil以清除图片和图片URL；</span><br><span class="line">[ano setImageWithURL:[NSURL URLWithString:testURL()] placeholder:placeholderImage() options:YYWebImageOptionUseNSURLCache manager:nil progress:nil transform:nil completion:nil];</span><br><span class="line">[self.view addSubview:ano];</span><br></pre></td></tr></table></figure></p>
<p>#pragma mark - CALayer 分类 之 YYAdd 和 YYWebImage（类似SDWebImage）<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">图片快速截图，图片旋转等操作；</span><br><span class="line">UIImageView *resultImageV = [UIImageView createImageViewWithFrame:CGRectMake(0, kTopHeight(), kScreenWidthForApp(), 300) imageName:nil];</span><br><span class="line">resultImageV.contentMode = UIViewContentModeScaleAspectFit;</span><br><span class="line">resultImageV.backgroundColor = [UIColor orangeColor];</span><br><span class="line">[self.view addSubview:resultImageV];</span><br><span class="line"></span><br><span class="line">UIImageView *imageV = [[UIImageView alloc]initWithFrame:CGRectMake(0, 320 + kTopHeight(), kScreenWidthForApp(), 300)];</span><br><span class="line">imageV.backgroundColor = kLightLightGrayColor();</span><br><span class="line">[imageV setImageWithURL:[NSURL URLWithString:testURL()] placeholder:placeholderImage()];</span><br><span class="line">[self.view addSubview:imageV];</span><br><span class="line"></span><br><span class="line">CAShapeLayer *shapler = [CAShapeLayer layer];</span><br><span class="line">[shapler setImageWithURL:[NSURL URLWithString:@&quot;https://desk-fd.zol-img.com.cn/t_s960x600c5/g5/M00/02/04/ChMkJ1bKx-iISS3nAAhg0DWRhY0AALH6gDF3lkACGDo264.jpg&quot;] placeholder:placeholderImage()];</span><br><span class="line">shapler.frame = CGRectMake(0, 0, 160, 160);</span><br><span class="line">[imageV.layer addSublayer:shapler];</span><br><span class="line"></span><br><span class="line">CAShapeLayer *shap11 = [CAShapeLayer layer];</span><br><span class="line">[shap11 setImageWithURL:[NSURL URLWithString:@&quot;https://www.fotor.com/images2/features/photo_effects/e_bw.jpg&quot;] placeholder:placeholderImage()];</span><br><span class="line">shap11.frame = CGRectMake(100, 200, 80, 80);</span><br><span class="line">[imageV.layer addSublayer:shap11];</span><br><span class="line"></span><br><span class="line">[imageV.layer setLayerShadow:kLightLavanderColor() offset:CGSizeMake(5, 5) radius:0];</span><br><span class="line"></span><br><span class="line">// 内容更改时，向图层内容添加淡入淡出动画。</span><br><span class="line">[shap11 addFadeAnimationWithDuration:2.0 curve:UIViewAnimationCurveEaseIn];</span><br><span class="line"></span><br><span class="line">NSData *pdfData = [imageV.layer snapshotPDF];</span><br><span class="line"></span><br><span class="line">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(5 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">shap11.transformDepth = 34/1000;// 深度</span><br><span class="line">shap11.transformRotation = 60;</span><br><span class="line">shapler.transformScale = 1.5;</span><br><span class="line">UIImage *snapImage = [imageV.layer snapshotImage];</span><br><span class="line">resultImageV.image = snapImage;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>}</p>
<p>#pragma mark - YYReachablity<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">这里涉及到两个枚举，一个用来区分WWAN 和 WIFI，另外一个用来区分WWAN内部的2G，3G，4G内部的网络类型；</span><br><span class="line">Mbps=Mbit/s 即兆比特每秒（1，000，000 bit/s），Million bits per second 的缩写，是一种传输速率单位，指每秒传输的位（比特）数量；</span><br><span class="line"></span><br><span class="line">typedef NS_ENUM(NSUInteger, YYReachabilityStatus) &#123;</span><br><span class="line">YYReachabilityStatusNone  = 0, ///&lt; Not Reachable</span><br><span class="line">YYReachabilityStatusWWAN  = 1, ///&lt; Reachable via WWAN (2G/3G/4G)</span><br><span class="line">YYReachabilityStatusWiFi  = 2, ///&lt; Reachable via WiFi</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">typedef NS_ENUM(NSUInteger, YYReachabilityWWANStatus) &#123;</span><br><span class="line">YYReachabilityWWANStatusNone  = 0, ///&lt; Not Reachable vis WWAN</span><br><span class="line">YYReachabilityWWANStatus2G = 2, ///&lt; Reachable via 2G (GPRS/EDGE)       10~100Kbps</span><br><span class="line">YYReachabilityWWANStatus3G = 3, ///&lt; Reachable via 3G (WCDMA/HSDPA/...) 1~10Mbps</span><br><span class="line">YYReachabilityWWANStatus4G = 4, ///&lt; Reachable via 4G (eHRPD/LTE)       100Mbps</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">@property(nonatomic,readonly) SCNetworkReachabilityFlags flags;</span><br><span class="line">这里用到了一个框架SystemConfiguration，这个枚举SCNetworkReachbilityFlags 就在这个框架里面，这里引入头文件#import &lt;SystemConfiguration/SystemConfiguration.h&gt;。</span><br><span class="line">SCNetworkReachabilityFlags flags = [YYReachability reachability].flags;// 指示指定的网络节点名称或地址是否可达，是否需要连接以及建立连接时是否需要某些用户干预的标志；</span><br><span class="line">* kSCNetworkReachabilityFlagsTransientConnection 该标志表示可以通过临时连接（如APP）访问指定的节点名称或地址；</span><br><span class="line">* kSCNetworkReachabilityFlagsReachable 该标志表示可以使用当前的网络配置来访问指定的节点名称或地址</span><br><span class="line">* kSCNetworkReachabilityFlagsConnectionRequired 该标志表示可以使用当前网络配置访问指定的节点名称或地址，但必须首先建立连接，作为一个例子，这个状态将返回一个当前不活动的拨号连接，但可以处理目标系统的网络流量；</span><br><span class="line">* kSCNetworkReachabilityFlagsConnectionOnTraffic 该标志表示可以使用当前网络配置访问指定的节点名称或地址，但必须首先建立连接。任何指向指定名称或地址的流量都将启动连接。注意：此标志以前名为kSCNetworkReachabilityFlagsConnectionAutomatic。</span><br><span class="line">* kSCNetworkReachabilityFlagsInterventionRequired 该标志表示可以使用当前网络配置来访问指定的节点名称或地址，但是另外需要某种形式的用户干预来建立此链接，例如提供密码，身份验证令牌等。注意：目前这个标志只会出现在你有拨号流量配置（ConnectionOnTraffic）的情况下，在这种情况下，已经进行了连接尝试，并且出现了一些错误（例如没有拨号音，没有应答，坏的密码，......）在自动连接尝试期间遇到。在这种情况下，PPP控制器将停止尝试建立连接，直到用户干预。</span><br><span class="line">* kSCNetworkReachabilityFlagsConnectionOnDemand 该标志表示可以使用当前的网络配置访问指定的节点名称或地址，但必须首先建立连接，连接将由CFSocketStream API”按需“建立，其他API不会建立连接。</span><br><span class="line">* kSCNetworkReachabilityFlagsIsLocalAddress 该标志表示指定的节点名称或地址是与当前系统上的网络连接关联的节点名称或地址。</span><br><span class="line">* kSCNetworkReachabilityFlagsIsDirect 该标志表示到指定节点名称或地址的网络流量不会通过网关，而是直接路由到系统中的某个接口；</span><br><span class="line">* kSCNetworkReachabilityFlagsIsWWAN 该标志表示可以通过 EDGE，GPRS或其他”cell“连接到达指定节点名称或地址。</span><br><span class="line"></span><br><span class="line">YYReachabilityStatus status = [YYReachability reachability].status;</span><br><span class="line">YYReachabilityWWANStatus wwanStatus = [YYReachability reachability].wwanStatus;</span><br><span class="line">GPRS（General Packet Radio Service）是通用分组无线服务技术的简称，它是GSM移动电话用户可用的一种移动数据业务，属于第二代移动通信中的数据传输技术。GPRS可说是GSM的延续。GPRS和以往连续在频道传输的方式不同，是以封包（Packet）式来传输，因此使用者所负担的费用是以其传输资料单位计算，并非使用其整个频道，理论上较为便宜。GPRS的传输速率可提升至56甚至114Kbps。</span><br><span class="line">EDGE（Enhanced Data Rate for GSM Evolution ，增强型数据速率GSM演进技术）是一种从GSM到3G的过渡技术，它主要是在GSM系统中采用了一种新的调制方法，即最先进的多时隙操作和8PSK调制技术。由于8PSK可将现有GSM网络采用的GMSK调制技术的信号空间从2扩展到8，从而使每个符号所包含的信息是原来的4倍。EDGE是一种介于第二代移动网络与第三代移动网络之间的过渡技术，因此也有人称它为&quot;二代半&quot;技术。</span><br><span class="line">WCDMA亦称宽带码分多址，是一种第三代无线通讯技术，是种由3GPP具体制定的，基于GSM MAP核心网，UTRAN（UMTS陆地无线接入网）为无线接口的第三代移动通信系统。 目前WCDMA有Release 99、Release 4、Release 5、Release 6等版本。 目前中国联通采用的此种3G通讯标准。</span><br><span class="line">HSDPA（High Speed Downlink Packet Access)高速下行分组接入，是一种移动通信协议，亦称为3.5G(3½G)。该协议在WCDMA下行链路中提供分组数据业务，在一个5MHz载波上的传输速率可达8-10 Mbit/s（如采用MIMO技术，则可达20 Mbit/s）。在具体实现中，采用了自适应调制和编码（AMC）、多输入多输出（MIMO）、混合自动重传请求（HARQ）、快速调度、快速小区选择等技术。</span><br><span class="line">HSUPA (high speed uplink packet access)高速上行链路分组接入。HSUPA通过采用多码传输、HARQ、基于Node B的快速调度等关键技术，使得单小区最大上行数据吞吐率达到5.76Mbit/s，大大增强了WCDMA上行链路的数据业务承载能力和频谱利用率。在引入HSDPA技术大幅提高下行链路的数据传输速率和吞吐量之后，为满足上行速率要求更高的业务发展需求，3GPP进一步开展了上行链路增强技术的研究。高速上行分组接入（High Speed Uplink Packet Access，HSUPA）即是3GPP协议体系在R6版本中引入的无线侧上行链路增强技术。HSUPA通过采用多码传输、HARQ、基于Node B的快速调度等关键技术，使得单小区最大上行数据吞吐率达到5.76Mbit/s，大大增强了WCDMA上行链路的数据业务承载能力和频谱利用率。TD-SCDMA系统与WCDMA系统采用的HSUPA技术较为类似，但TD-SCDMA系统的标准化进展稍滞后于WCDMA。</span><br><span class="line">LTE（Long Term Evolution，长期演进)是由3GPP（The 3rd Generation Partnership Project，第三代合作伙伴计划）组织制定的UMTS（Universal Mobile Telecommunications System，通用移动通信系统）技术标准的长期演进，于2004年12月在3GPP多伦多会议上正式立项并启动。LTE系统引入了OFDM（Orthogonal Frequency Division Multiplexing，正交频分复用）和MIMO（Multi-Input &amp; Multi-Output，多输入多输出）等关键技术，显著增加了频谱效率和数据传输速率（20M带宽2X2MIMO在64QAM情况下，理论下行最大传输速率为201Mbps，除去信令开销后大概为150Mbps，但根据实际组网以及终端能力限制，一般认为下行峰值速率为100Mbps，上行为50Mbps），并支持多种带宽分配：1.4MHz，3MHz，5MHz，10MHz，15MHz和20MHz等，且支持全球主流2G/3G频段和一些新增频段，因而频谱分配更加灵活，系统容量和覆盖也显著提升。</span><br><span class="line"></span><br><span class="line">BOOL reachable = [YYReachability reachability].reachable;// 直接判断网络是否可达；</span><br><span class="line"></span><br><span class="line">+ (instancetype)reachability;</span><br><span class="line">该方法的作用就是监测默认路由的可达性。</span><br><span class="line"></span><br><span class="line">[YYReachability reachability].notifyBlock = ^(YYReachability * _Nonnull reachability) &#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">// 该属性的作用就是当网络状态发生变化后，就会在主线程通过block进行回调；</span><br><span class="line"></span><br><span class="line">YYReachability *reachability = [YYReachability reachabilityWithHostname:@&quot;https://www.baidu.com&quot;];// 判断给定的host的可达性</span><br><span class="line">YYReachability *reach = [YYReachability reachabilityWithAddress:@&quot;128.106.1.111&quot;];//判断给定IP地址的可达性</span><br></pre></td></tr></table></figure></p>
<p>#pragma mark - 线程安全计数器YYSentinel<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">YYSentinel是一个线程计数器，可以在一些多线程环境下使用；</span><br><span class="line"></span><br><span class="line">@property(readonly)int32_t value;</span><br><span class="line">返回计数器当前值。</span><br><span class="line"></span><br><span class="line">- (int32_t)increase;</span><br><span class="line">自动增加计数器的值。</span><br></pre></td></tr></table></figure></p>
<p>#pragma mark - 线程安全的可变数组子类YYThreadSafeArray部分<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">这个类主要就是线程安全可变数组的简单实现；通常访问性能对于NSMutableArray，但高于使用@synchoronized，NSLock或pthread_mutex_t;与NSArray(YYAdd)和NSMutableArray(YYAdd)中的自定义方法兼容；快速枚举enumerate(for...in)和枚举器不是线程安全的，使用block进行遍历枚举。当使用block/callblock进行遍历时，不要向block/callblock内部的数组发送消息。</span><br><span class="line">NSArray *array = @[@&quot;a&quot;,@&quot;ka&quot;,@&quot;dga&quot;,@&quot;fsg&quot;,@&quot;gshsh&quot;];</span><br><span class="line">[array enumerateObjectsUsingBlock:^(id  _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123;</span><br><span class="line"></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure></p>
<p>#pragma mark - YYTimer 定时器<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">YYTimer是基于GCD的线程安全的计数器，它和NSTimer类似的API，YYTimer对象和NSTimer在下面几个方式不同：</span><br><span class="line">* 它使用GCD产生时钟tick，不受runloop影响；</span><br><span class="line">* 它对target是weak修饰，所以可以避免引用循环；</span><br><span class="line">* 它在主线程上开启</span><br><span class="line"></span><br><span class="line">- (void)timerCreate:(UIButton *)button &#123;</span><br><span class="line">// 信号量：semaphore</span><br><span class="line">//    dispatch_semaphore_t sema = dispatch_semaphore_create(1); // 创建一个信号量</span><br><span class="line">//    dispatch_semaphore_signal(sema);// 发送一个信号</span><br><span class="line">//    dispatch_semaphore_wait(sema, 10);// 等待信号</span><br><span class="line"></span><br><span class="line">// 必须设置为全局变量，否则运行一次不再运行；</span><br><span class="line">YYTimer *timer = [YYTimer timerWithTimeInterval:1 target:self selector:@selector(yyTimerTexrst:) repeats:YES];</span><br><span class="line">[timer fire];</span><br><span class="line">self.timer = timer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)yyTimerTexrst:(YYTimer *)timer &#123;</span><br><span class="line">self.timerCount -= 1;</span><br><span class="line">NSLog(@&quot;timeCount: = %li&quot;,self.timerCount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>#pragma mark - 事物 YYTransaction<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">YYTransaction让你在当前runloop休眠之前执行一个selector一次；</span><br><span class="line"></span><br><span class="line">+ (YYTransaction *)transactionWithTarget:(id)target selector:(SEL)selector;</span><br><span class="line">target: 一个指定的target，这个target被持有，知道runloop结束；</span><br><span class="line">selector：target的selector；</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/25/iOS通用链接配置（点击网页直接打开APP的详情页面）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="aHuang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="机灵猴">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/25/iOS通用链接配置（点击网页直接打开APP的详情页面）/" itemprop="url">iOS通用链接配置（点击网页直接打开APP的详情页面）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-25T17:36:11+08:00">
                2019-03-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="https://www.jianshu.com/p/53588cf8dbc8" target="_blank" rel="noopener">https://www.jianshu.com/p/53588cf8dbc8</a><br><a href="https://www.jianshu.com/p/1970fd59de12" target="_blank" rel="noopener">https://www.jianshu.com/p/1970fd59de12</a><br><a href="http://www.cnblogs.com/ysk-china/p/5777299.html" target="_blank" rel="noopener">http://www.cnblogs.com/ysk-china/p/5777299.html</a><br><a href="http://strivingboy.github.io/blog/2015/09/27/ios9/" target="_blank" rel="noopener">http://strivingboy.github.io/blog/2015/09/27/ios9/</a><br><a href="https://www.jianshu.com/p/734c3eff8feb" target="_blank" rel="noopener">https://www.jianshu.com/p/734c3eff8feb</a><br>下面摘自小孩的技术博客：</p>
<h3 id="iOS9-Universal-Links-（通用链接）"><a href="#iOS9-Universal-Links-（通用链接）" class="headerlink" title="iOS9 Universal Links （通用链接）"></a>iOS9 Universal Links （通用链接）</h3><h4 id="“What-is-Universal-Links-”"><a href="#“What-is-Universal-Links-”" class="headerlink" title="“What is Universal Links?”"></a>“What is Universal Links?”</h4><p>Apple 推出通用链接：一种能够方便的通过传统 HTTP 链接来启动 APP, 使用相同的网址打开网站和 APP。<br>通过唯一的网址, 不需要特别的schema就可以链接一个特定的视图到APP 里面 。比如：在微信中使用了通用链接, 那么用户在Safari、UIWebView或者 WKWebView点击一个链接, iOS设备上的微信app怎会在微信里面自动打开这个页面, 如果没有安装则在Safrai中打开响应链接。<br><!--阅读全文--></p>
<blockquote>
<p>NOTE: Universal links let iOS 9 users open your app when they tap links to your website within WKWebView and UIWebView views and Safari pages, in addition to links that result in a call to openURL:, such as those that occur in Mail, Messages, and other apps.</p>
</blockquote>
<p>For users who are running versions of iOS earlier than 9.0, tapping a universal link to your website opens the link in Safari.</p>
<h4 id="“How-to-support-Universal-Links-”"><a href="#“How-to-support-Universal-Links-”" class="headerlink" title="“How to support Universal Links?”"></a>“How to support Universal Links?”</h4><ul>
<li>Step1:创建一个json 格式的apple-app-site-associatio 文件如下：<br>{<pre><code>&quot;applinks&quot;: {
    &quot;apps&quot;: [],
    &quot;details&quot;: [
        {
            &quot;appID&quot;: &quot;9JA89QQLNQ.com.apple.wwdc&quot;,
            &quot;paths&quot;: [ &quot;/wwdc/news/&quot;, &quot;/videos/wwdc/2015/*&quot; ]
        },
        {
            &quot;appID&quot;: &quot;TeamID.BundleID2&quot;,
            &quot;paths&quot;: [ &quot;*&quot; ]
        }
    ]
}
</code></pre>}</li>
</ul>
<p>根据 paths 键设定允许的路径列表, 或只是一个星号如果你想打开 APP 而不管路径是 什么<br>注意：paths 路径是大小写敏感的<br>NOTE:The website paths you specify in the paths array are case sensitive.”<br>“appID”组成部分：TeamID + BundleId TeamID可以从苹果开发账号页面也“Your Account”下查看，BundleId就直接在工程里看了</p>
<ul>
<li>Step2:上传 apple-app-site-association 文件<br>注意：<br>1、上传到web server根目录下<br>2、web server 需要支持https,客户端需要通告https访问，并且不支持任何重定向<br>upload it to the root of your HTTPS web server. The file needs to be accessible via HTTPS—without any redirects—at https:///apple-app-site-association. Next, you need to handle universal links in your app.</li>
<li>Step3:在 APP 里处理通用链接<ul>
<li>1、添加域名到 Capabilities<br>在 Xcode 的 capabilities 里 添加你的 APP 域名, 必须用 applinks: 前置它这将使APP从上门的域名请求Step2中创建的JSON 文件 apple-app-site-association。当你第一次启动 APP，它会从 <a href="https://domain.com/apple-app-site-association" target="_blank" rel="noopener">https://domain.com/apple-app-site-association</a> 下载这个文件。</li>
<li>2、在 AppDelegate 里支持通用链接<br>实现： </li>
</ul>
</li>
</ul>
<ul>
<li>(BOOL)application:(UIApplication <em>)application continueUserActivity:(NSUserActivity </em>)userActivity restorationHandler:(void (^)(NSArray *restorableObjects))restorationHandler方法，如下：<br><img src="../images/tongyonglianjie01.jpg" alt="tongyonglianjie01"><br>当 userActivity 是 NSUserActivityTypeBrowsingWeb 类型, 则意味着它已经由通用链接 API 代理。这样的话, 它保证用户打开的 URL 将有一个非空的 webpageURL 属性<h4 id="最后也是最重要的一点就是："><a href="#最后也是最重要的一点就是：" class="headerlink" title="最后也是最重要的一点就是："></a>最后也是最重要的一点就是：</h4>如果网页链接打开的页面显示apple-app-site-association这段json文件里面的内容就说明配置已经成功了；需要用Safari打开网页链接，所以这里为了用户体验，web端需要做页面引导：这时如果是在真机调试的话会进入continueUserActivity方法；只能真机测试，只能是Https的域名；<br>xcode代码配置方法：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">// response to universal links</span><br><span class="line">- (BOOL)application:(UIApplication *)application continueUserActivity:(nonnull NSUserActivity *)userActivity restorationHandler:(nonnull void (^)(NSArray&lt;id&lt;UIUserActivityRestoring&gt;&gt; * _Nullable))restorationHandler &#123;</span><br><span class="line">    // 我们需要的跳转</span><br><span class="line">    if ([userActivity.activityType isEqualToString:NSUserActivityTypeBrowsingWeb]) &#123;</span><br><span class="line">        NSURL *webPageUrl = userActivity.webpageURL;</span><br><span class="line">        NSString *host = webPageUrl.host;</span><br><span class="line">#ifdef DEBUG</span><br><span class="line">      NSLog(@&quot;-----host=%@,port=%@,user=%@,password=%@,path=%@,fragnment=%@,prametarString=%@,query=%@,relativePath=%@&quot;,webPageUrl.host,webPageUrl.port,webPageUrl.user,webPageUrl.password,webPageUrl.path,webPageUrl.fragment,webPageUrl.parameterString,webPageUrl.query,webPageUrl.relativePath);</span><br><span class="line">#endif</span><br><span class="line">        if ([host containsString:@&quot;wasaisports.com&quot;]) &#123;</span><br><span class="line">            // 需要跳转到自己的APP</span><br><span class="line">            ActivityDetailViewController *vc = [[ActivityDetailViewController alloc]init];</span><br><span class="line">            NSString *query = webPageUrl.query;</span><br><span class="line">            NSArray *queryArray = [query componentsSeparatedByString:@&quot;&amp;&quot;];</span><br><span class="line">            __block NSString *activityID = @&quot;&quot;;</span><br><span class="line">            __block NSString *clabId = @&quot;&quot;;</span><br><span class="line">            [queryArray enumerateObjectsUsingBlock:^(NSString*  _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123;</span><br><span class="line">                if (idx == 0) &#123;</span><br><span class="line">                    NSString *queryString = [obj stringByReplacingOccurrencesOfString:@&quot;activityId=&quot; withString:@&quot;&quot;];</span><br><span class="line">                    activityID = queryString;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    NSString *queryString = [obj stringByReplacingOccurrencesOfString:@&quot;clabId=&quot; withString:@&quot;&quot;];</span><br><span class="line">                    clabId = queryString;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;];</span><br><span class="line">            vc.activityId = activityID;</span><br><span class="line">            [[ToolUtil getCurrentViewController].navigationController pushViewController:vc animated:YES];</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            // 无法识别的域名，Safari打开</span><br><span class="line">            if (@available(iOS 10.0, *)) &#123;</span><br><span class="line">                [[UIApplication sharedApplication] openURL:webPageUrl options:nil completionHandler:nil];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                [[UIApplication sharedApplication] openURL:webPageUrl];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>json文件的配置：配置完之后要给后台上传到服务器根目录下；</p>
<h4 id="么有下载APP时的跳转"><a href="#么有下载APP时的跳转" class="headerlink" title="么有下载APP时的跳转:"></a>么有下载APP时的跳转:</h4><p>需要前端或者后台那边做是否已经下载安装APP的判断，如果已经下载直接请求苹果端配置的json文件，iOS 拦截URL地址判断进入指定的页面；如果没有安装APP就不请求这个json配置文件，重定向到APP Store的下载链接；<br>后台重定向：配置json文件必须在.wellKnown 下获取才可以重定向<br><a href="http://www.wasaisports.com/.well-known/apple-app-site-association（web给的链接应该是这样子的，才可以在么有安装APP的时候将链接重定向到APPStore）" target="_blank" rel="noopener">http://www.wasaisports.com/.well-known/apple-app-site-association（web给的链接应该是这样子的，才可以在么有安装APP的时候将链接重定向到APPStore）</a><br>重定向问题：需要一个演示操作，如果没有延时，就会直接先弹出去APP Store 的弹出框，不会跳到详情页；<br>重定向问题：json文件没有读取到：<br><img src="../images/tongyonglianjie02.jpg" alt="tongyonglianjie02"><br><img src="../images/tongyonglianjie02.jpg" alt="tongyonglianjie03"><br>点击可以跳转到APPStore。<br>后台重定向解决办法：<br>后台必须先请求到json文件后延时2000ms（或者其他合适的时间），然后再走重定向方法；</p>
<h4 id="知乎的universal-link-制作流程："><a href="#知乎的universal-link-制作流程：" class="headerlink" title="知乎的universal link 制作流程："></a>知乎的universal link 制作流程：</h4><p>测试链接： <a href="https://www.zhihu.com/question/22914651" target="_blank" rel="noopener">https://www.zhihu.com/question/22914651</a><br>未安装APP的流程和已经下载安装的流程 自测一下，截图就不贴了。</p>
<h4 id="Universal-Link-打开APP前端部署采坑记"><a href="#Universal-Link-打开APP前端部署采坑记" class="headerlink" title="Universal Link 打开APP前端部署采坑记"></a>Universal Link 打开APP前端部署采坑记</h4><blockquote>
<blockquote>
</blockquote>
<p>Schema VS Universal Link<br>Deeplink相关的技术，在wap中唤起app其实应用最最广泛的并不是Universal Link，而是直接Schema跳转<br>location.href = ‘schema://xxxx’<br>并且一般各大APP都会给自己做一套路由体系，这样其实可以直接在schema头后面对接路由体系，做到一行schema定位打开任意App内功能界面（我就不详细扯路由的事了）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)application:(UIApplication *)application openURL:(NSURL *)url sourceApplication:(NSString *)sourceApplication annotation:(id)annotation &#123;</span><br><span class="line">    if ([[url absoluteString] hasPrefix:@&quot;schema://&quot;]) &#123;</span><br><span class="line">        [[WKDispatcher sharedInstance] operationObjectFromRouteURL:[url absoluteString]];//路由</span><br><span class="line">        return YES;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>如果单纯为了实现deeplink — 在WAP上打开App，并且传递来数据信息，定位App内的具体逻辑，那么Schema就够了，其实没必要上Universal Link，Schema相当于是很特殊的Url，他是schema://xxx这种样子，如果安装了APP才能支撑跳转这种Schema Url，如果没安装APP就没任何效果，而Universal Link则是把普通url，长<a href="http://xxx.xxx.xxx/xxx这样的Normal" target="_blank" rel="noopener">http://xxx.xxx.xxx/xxx这样的Normal</a> Url，如果安装了App，就能像Schema一样传递给App，延续App内逻辑，如果没装App，则还会继续在浏览器里跳转这个Normal Url</p>
<blockquote>
<blockquote>
</blockquote>
<p>Schema的弊端<br>Schema无法判断是否安装App<br>一定会有这样的产品需求的：</p>
<ul>
<li>如果已经安装App，则打开App</li>
<li>如果没有安装App，则前往下载App<br>浏览器实际上是没有能力判断手机里是否安装了某个App的，所以聪明的程序员们选择了讨巧的方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    var appSchema = &apos;schema://xxxx&apos;;</span><br><span class="line">    if ($.os.ios) &#123;</span><br><span class="line">        location.href = openNALocation; //location.href 打开schema</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        $(&apos;body&apos;).append(&apos;&lt;iframe src=&quot;&apos; + appSchema + &apos;&quot;&gt;&lt;/iframe&gt;&apos;); //iFrame 打开 schema</span><br><span class="line">    &#125; </span><br><span class="line">&#125;catch (e) &#123;&#125;</span><br><span class="line">//延迟1000秒</span><br><span class="line">setTimeout(function () &#123;</span><br><span class="line">    if ($.os.ios) &#123;</span><br><span class="line">        location.href = `https://itunes.apple.com/us/app/idxxxxxxx?mt=8`;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        location.href = `https://xxx.xxx.xxx/xxx/xxx.apk`;//直接apk下载link</span><br><span class="line">    &#125; </span><br><span class="line">&#125;，1000）</span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<ul>
<li>首先发起跳转Schema<ul>
<li>如果没安装App，会打开App失败，没效果</li>
<li>如果安装App，会成功打开App</li>
</ul>
</li>
<li>延迟1000ms<ul>
<li>如果没安装App，Schema打开失败，等1000秒后会自动跳转</li>
<li>如果安装App，App会打开，当前网页会被暂停，这延迟代码不会执行<br>聪明的人会发现，这样有个风险，如果用户打开APP成功后，又手动切回浏览器，那么延迟1000ms的代码依然会执行，安卓会跳出下载apk包得提示，iOS会又再度跳到Appstore，但这个瑕疵也不是太大的问题，所以这种做法被普遍采用，运用在各种安装就跳转，不安装就下载的用户场景。<br>安卓这么用挺好，iOS有个讨厌的弹框<br>如果用户没有安装App，那么他一定会经历2个事情</li>
</ul>
</li>
<li>schema打开app，但是失败</li>
<li>延迟后，跳转下载App<br>在第一个环节，安卓上schema打开失败，没有任何反映，也没有任何提示，一切顺利，但是iOS就不同了。<br>schema会弹个可恶的跳转失败的框<br><img src="../images/tongyonglianjie04.jpng" alt="tongyonglianjie04"><br>然后再延迟后弹跳转AppStore的框<br><img src="../images/tongyonglianjie05.jpg" alt="tongyonglianjie05"><blockquote>
<blockquote>
</blockquote>
<p>Schema被很多App禁止，比如微信手百<br>Schema被广泛使用，从浏览器中唤起打开专门的App，但这并不被很多App认可，比如微信，手机百度，他们本身除了浏览网页以外有其他的使用场景，所以站在微信/手百的角度，并不希望用户为了看一些分享和内容就跳出微信/手百的App，于是这些客户端拦截了Schema，使得所有Schema都无法生效。<br>于是不得已，广大开发者只好针对，微信/手百，等特殊UA信息，展现出蒙层，引导用户用系统/外部浏览器打开</p>
<blockquote>
</blockquote>
<p>Universal Link 解决 Schema的弊端<br>开篇就说了，如果你单纯为了能让wap打开App，Schema就能做到了，Universal Link的意义则是把普通url，也赋予了能打开App的能力，而不必编写专门的Schema Url去唤起App<br>Schema 的2个弊端确实能通过Universal Link解决<br>不同于Schema，在没装App的时候，Universal Link他也是一个合法的url链接，浏览器可以正常跳转，因此不会出现在iOS上讨人厌的框<br>Universal Link目前还没有基于iOS的UI/WKWebView的应用进行拦截，所以目前看还是能突破微信/手百的封锁。（以后，不好说啊~）</p>
<blockquote>
</blockquote>
<p>Universal Link 开发<br>类似的话题，随便搜搜Universal Link能搜到一大堆，我这里就略微多啰嗦两句，一般各大教程里会反复说的，我尽量一带而过，多说点我遇到的坑</p>
</blockquote>
<h4 id="配置apple-app-association"><a href="#配置apple-app-association" class="headerlink" title="配置apple-app-association"></a>配置apple-app-association</h4>究竟哪些的url会被识别为Universal Link，全看这个apple-app-association文件<br><a href="https://developer.apple.com/library/content/documentation/General/Conceptual/AppSearch/UniversalLinks.html" target="_blank" rel="noopener">Apple Document UniversalLinks.html</a></li>
<li>你的域名必须支持Https</li>
<li>域名根目录下放这个文件apple-app-association，不带任何后缀</li>
<li>文件为json保存为文本即可</li>
<li>json按着官网要求填写即可<br>怎么写json其实没啥可教的，满世界的文章都教你咋写了，我们看个例子，点下面的链接，你的浏览器就会自动把知乎的apple-app-association的json file给down下来<br><a href="https://oia.zhihu.com/apple-app-site-association" target="_blank" rel="noopener">知乎的 apple-app-association 文件</a><br>划重点<br>有心人可能看到，知乎的Universal Link配置的是 oia.zhihu.com 这个域名，并且对这个域名下比如/answers /questions /people 等urlpath进行了识别，也就是说，知乎的universal link，只有当你访问 <a href="https://oia.zhihu.com/questions/xxxx，在移动端会触发Universal" target="_blank" rel="noopener">https://oia.zhihu.com/questions/xxxx，在移动端会触发Universal</a> Link，而知乎正经的Urlhttps//<a href="http://www.zhihu.com/questions/xxx是不会触发Universal" target="_blank" rel="noopener">www.zhihu.com/questions/xxx是不会触发Universal</a> Link的，知乎为什么制作，为什么不把他的主域名配置Universal Link，这是由于Universal Link的一个大坑所致<br>PS.<blockquote>
<p>apple-app-association 你可以看完全了知乎的json file，会发现里面也不止是 universal link<br>苹果的一些其他功能都和apple-app-association有关，都需要配置这个文件，增加更多json字段信息<br>比如Hand off 还有一些跨Web&amp;App的分享</p>
</blockquote>
<h4 id="测试是否正确"><a href="#测试是否正确" class="headerlink" title="测试是否正确"></a>测试是否正确</h4>苹果官方提供了一个网站来测试你配置的域名apple-app-association是否正常work<br><a href="https://search.developer.apple.com/appsearch-validation-tool/" target="_blank" rel="noopener">https://search.developer.apple.com/appsearch-validation-tool/</a><br>这个网站有点SB，就是你用他测试不通过，其实Universal Link也可能不生效的，比如我把知乎的oia.zhihu.com输入进去，他就没感应到，认为没有。我搜索的时候，发现也有人发现了这个问题，反正可以当个参考<h4 id="配置iOS-App工程"><a href="#配置iOS-App工程" class="headerlink" title="配置iOS App工程"></a>配置iOS App工程</h4></li>
<li>开发者中心证书打开Associated Domains</li>
<li>工程配置Associated Domains</li>
<li>将你apple-app-association所在域名配置进去</li>
<li>给你的工程像Schema的OpenUrl一样，编写App被唤醒后的处理逻辑<br><img src="../images/tongyonglinajie06.jpg" alt="tongyonglinajie06"><br>#pragma mark Universal Links<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)application:(UIApplication *)application continueUserActivity:(NSUserActivity *)userActivity restorationHandler:(void (^)(NSArray * _Nullable))restorationHandler &#123;</span><br><span class="line">    if ([userActivity.activityType isEqualToString:NSUserActivityTypeBrowsingWeb]) &#123;</span><br><span class="line">        NSURL *webUrl = userActivity.webpageURL;</span><br><span class="line">        [self handleUniversalLink:webUrl]; // 转化为App路由</span><br><span class="line">    &#125;</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>恩比较千篇一律，我不多说了</p>
<h4 id="Universal-Link的基本运作流程"><a href="#Universal-Link的基本运作流程" class="headerlink" title="Universal Link的基本运作流程"></a>Universal Link的基本运作流程</h4><ul>
<li>APP第一次启动 or APP更新版本后第一次启动</li>
<li>APP向工程里配置的域名发起Get请求拉取apple-app-association Json File</li>
<li>APP将apple-app-association注册给系统</li>
<li>由任意webview发起跳转的url，如果命中了apple-app-association注册过的通用链接</li>
<li>打开App，触发Universal Link delegate</li>
<li>没命中，webview继续跳转url<br>在你进行apple-app-association 以及 App工程的配置之后，整个Universal Link的运作流程完全由系统控制了<h3 id="Universal-Link-采坑"><a href="#Universal-Link-采坑" class="headerlink" title="Universal Link 采坑"></a>Universal Link 采坑</h3>整个Universal Link其实真要只是开发完成，完全写不了几行代码，就差不多搞定了，不过还真是踩了几个坑<h4 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h4>前端开发经常面临跨域问题，恩Universal Link也有跨域问题，但不一样的是，Universal Link，必须要求跨域，如果不跨域，就不行，就失效，就不工作。（iOS 9.2之后的改动，苹果就这么规定这么设计的）<br>这也是上面拿知乎举例子的时候重点强调的一个问题，知乎为什么使用oia.zhihu.com做Universal Link？</li>
<li>假如当前网页的域名是 A</li>
<li>当前网页发起跳转的域名是 B</li>
<li>必须要求 B 和 A 是不同域名，才会触发Universal Link</li>
<li>如果B 和 A 是相同域名，只会继续在当前WebView里面进行跳转，哪怕你的Universal Link一切正常，根本不会打开App<br>是不是不太好理解，那直接拿知乎举例子<br><a href="https://www.zhihu.com/question/22914651" target="_blank" rel="noopener">https://www.zhihu.com/question/22914651</a><br>知乎的一般网页URL都是<a href="http://www.zhihu.com域名，你在微信朋友圈看到了知乎的问题分享，如果copy" target="_blank" rel="noopener">www.zhihu.com域名，你在微信朋友圈看到了知乎的问题分享，如果copy</a> url 你就能看到这样的链接<br>微信里其实是屏蔽Schema的，但是你依然能看到大大的一个按钮App内打开，这确实就是通过Universal Link来实现的，但如果知乎把Universal Link 配在了<a href="http://www.zhihu.com域名，那么即便已经安装了App，Universal" target="_blank" rel="noopener">www.zhihu.com域名，那么即便已经安装了App，Universal</a> Link也是不会生效的。<br>一般的公司都会有自己的主域名，比如知乎的<a href="http://www.zhihu.com，在各处分享传播的时候，也都是直接分享基于主域名的url，但为了解决苹果强制要求跨域才生效的问题，Universal" target="_blank" rel="noopener">www.zhihu.com，在各处分享传播的时候，也都是直接分享基于主域名的url，但为了解决苹果强制要求跨域才生效的问题，Universal</a> Link就不能配置在主域名下，于是知乎才会准备一个oia.zhihu.com域名，专为Universal Link使用，不会跟任何主动传播分享的域名撞车，从而在任何活动WAP页面里，都能顺利让Universal Link生效。<br>简单一句话</li>
<li>只有当前webview的url域名，与跳转目标url域名不一致时，Universal Link 才生效<h4 id="apple-app-association-覆盖"><a href="#apple-app-association-覆盖" class="headerlink" title="apple-app-association 覆盖"></a>apple-app-association 覆盖</h4>我们业务机房的集群是大部门下几条业务线共用的，有一整套云服务系统来进行机房集群的管理，有统一的接入层进行分发。虽然是不同的产品线，不同的服务，但是共享分布式的机房进行运作的。<br>很多Universal Link的教学文章是这么写的</li>
<li>将json命名为 apple-app-association 不要乱改名</li>
<li>将file 上传到域名所在的服务器根目录下<br>于是我就将我们文库的apple-app-association，上传到我准备的wenkuUniversal域名的所在机器的根目录下。（因为机房都是分布式的，所以其实就是upload的全部门下的很多机器上）<br>同部门另一个产品线阅读后来也开始尝试Universal Link，也要把他们写好的apple-app-association上传到他们的yueduUniversal域名所在的机器的根目录下。<br>因为都是同样的文件名，又因为整个事业部机器实际上是共用的，因此就发生了覆盖。<br>解决办法</li>
<li>共用同一个 apple-app-association<br>因为apple-app-association的具体内容里有App 的Bundle ID在，因此可以简单的把2个json file 进行merge，你的App bundle 生效你的link，我的App bundle生效我的link<br>但其实并不推荐，毕竟双方都要小心在更新的时候，不能覆盖对方，并且这样做也很不合理，apple-app-association也不止为universal link 一个feature工作，当面临跨app / web share 甚至hand off的时候，共用一个json file 还是有坑</li>
<li>接入层分发不同json file<br>2个产品线的link域名其实是不一样的，只不过恰巧这两个域名最重打到得机器是同一个或者说有重叠，因此产生了覆盖，完全可以将json文件保存成各自的名字，在接入层对域名进行分发<br>最终App也是通过Get请求去拉取apple-app-association的，只要Get到，并且ssl安全性上符合要求（强制https）就没问题<br>隐藏的坑：apple-app-association被覆盖后如何更新<br>我们线上已经work的Universal Link功能，突然有一天发现坏了，查了一圈最后查到被阅读覆盖了，那就修复呗，修复倒是没问题，问题在于修复后的universal link，用户必须重新安装一次app，才能重新work，这个太坑了啊<br>所以关键是需要掌握apple-app-association的更新时机，反复重新杀APP重开完全没用，删了APP重装确实有用，但不可能让用户这么去做<br><a href="https://stackoverflow.com/questions/35187576/does-the-apple-app-site-association-json-file-ever-get-updated-in-app" target="_blank" rel="noopener">https://stackoverflow.com/questions/35187576/does-the-apple-app-site-association-json-file-ever-get-updated-in-app</a><br>这里解释了，每次App安装后的第一次Launch，会拉取apple-app-association，除此之外在Appstore每次App的版本更新后的第一次Launch，也会拉取apple-app-association。<br>也就是说，一旦不小心因为意外apple-app-association，想要挽回又让那部分用户无感，App再发一个版本就好了<h3 id="Universal-Link-会因为用户行为而失效"><a href="#Universal-Link-会因为用户行为而失效" class="headerlink" title="Universal Link 会因为用户行为而失效"></a>Universal Link 会因为用户行为而失效</h3>Universal Link 触发后打开App，这时候App的状态栏右上角会有文字提示来自XXApp，可以点状态栏的文字快速返回原来的AP<br>如果用户点了返回微信，就会被苹果记住，认为用户并不需要跳出原App打开新App，因此这个App的Universal Link会被关闭，再也无效。<br>想要开启也不是不行，让用户重新用safari打开，universal link的页面，然后会出现很像苹果smart bar的东西，那个东西点了后就能打开（我是看到的，我没亲自操作过）<h3 id="Universal-Link-业务部署"><a href="#Universal-Link-业务部署" class="headerlink" title="Universal Link 业务部署"></a>Universal Link 业务部署</h3>知乎的apple-app-association可以看到里面有一大堆的WAP的URL，比如/answers /questions /people等，知乎都将它一一映射到App得对应界面里，问题/回答/人详情页。这是因为知乎的WAP站和APP的功能几乎是一致的。因此知乎的Universal Link的使用方式，可以说是很经典的遵循着苹果的原始设计初衷通用链接，将wap url，变成通用url，同样的url，对应着2个跳转，web跳转/app跳转，但是他们是同一个功能。<br>我们产品线面临的情况不一样，我们的产品线文库，他的WAP和APP功能差异非常大，可以说除了文档阅读页/view，WAP与APP都有这个功能，其他的功能WAP是WAP的，APP是APP的，形态和场景都有明显差异。除了/view这个功能，我们可以按着通用链接的设计，将APP阅读页跳转，与WAP阅读页跳转进行统一。其他时候Universal Link对于我们业务来说就是一个更强大的Schema（突破旧Schema局限的=），他只需要跳转到APP，他没有合法的WAP Url可以让浏览器在没有安装App的情况下继续跳转。<h4 id="我们的Universal-Link-业务部署"><a href="#我们的Universal-Link-业务部署" class="headerlink" title="我们的Universal Link 业务部署"></a>我们的Universal Link 业务部署</h4>我们的Universal Link就像知乎一样，没有选择我们的主域名，而是选了一个完全没在WAP上有任何页面和流量的域名，我们的apple-app-association是这么写的<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;appID&quot;: &quot;xxxxxx.xxx.xxx.xxxxx&quot;,</span><br><span class="line">    &quot;paths&quot;:[ &quot;/view/*&quot;,</span><br><span class="line">              &quot;/_iosuniversallink/*&quot;]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>我们的AppDelegate中具体handleUniversalLink的逻辑是这么写的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)handleUniversalLink:(NSURL *)url &#123;</span><br><span class="line">    NSURLComponents *components = [NSURLComponents componentsWithURL:url resolvingAgainstBaseURL:YES];</span><br><span class="line">    NSString *host = components.host;</span><br><span class="line">    if ([host isEqualToString:@&quot;xxx.xxx.xxx&quot;]) &#123; //host判断，虽然没啥意义</span><br><span class="line">        if (pathComponents.count &gt;= 3) &#123;</span><br><span class="line">            //地址匹配+页面跳转</span><br><span class="line">            NSString *router;</span><br><span class="line">            if ([pathComponents[1] isEqualToString:@&quot;view&quot;]) &#123;</span><br><span class="line">                router = @&quot;xxx&quot;;//生成打开APP阅读页的专属Router</span><br><span class="line">            &#125; else if ([pathComponents[1] isEqualToString:@&quot;_iosuniversallink&quot;]) &#123;</span><br><span class="line">                router = @&quot;xxx&quot;;//解析出APP能识别的任意路由，</span><br><span class="line">            &#125;</span><br><span class="line">            if (router &amp;&amp; router.length &gt; 0) &#123;</span><br><span class="line">                [[WKDispatcher sharedInstance] operationObjectFromRouteURL:router];//无论是阅读页路由还是任意路由，发起跳转</span><br><span class="line">            &#125;</span><br><span class="line">            return YES;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看出来我只打开了这个域名下<a href="https://xxx.xxx.xxx/view/" target="_blank" rel="noopener">https://xxx.xxx.xxx/view/</a><em> 和 <a href="https://xxx.xxx.xxx/_iosuniversallink/" target="_blank" rel="noopener">https://xxx.xxx.xxx/_iosuniversallink/</a></em>2个Universal Link Path.对没错，不像知乎那么多。</p>
<ul>
<li>/view/<em> 后面的</em>直接是阅读页ID，用于快速生成阅读页路由，发起跳转</li>
<li>/_iosuniversallink/<em> 后面的</em>其实应该填写的是我们App已经设计好的路由字符串，识别出路由字符串后，发起跳转<br>其实可以看出来/_iosuniversallink是完全包含/view的，因为APP阅读页天然也是包含在我们的路由规则内的，只要这里有路由策略，扩展力已经足够支持任意APP页面了，因此apple-app-association只配置了2个，但是如果有计划外的特殊case，大不了更新一下，也没多大事。<h4 id="为了统一WAP-amp-APP，为了通用链接的效果"><a href="#为了统一WAP-amp-APP，为了通用链接的效果" class="headerlink" title="为了统一WAP&amp;APP，为了通用链接的效果"></a>为了统一WAP&amp;APP，为了通用链接的效果</h4>我刚才提到，我们选择的Universal Link的域名其实是一个没有实际页面的域名，也就是说<a href="https://xxx.xxx.xxx/view/*这个url，如果没安装APP因此触发WebView继续跳转原地址，会直接404。处理很简单，重定向一下" target="_blank" rel="noopener">https://xxx.xxx.xxx/view/*这个url，如果没安装APP因此触发WebView继续跳转原地址，会直接404。处理很简单，重定向一下</a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">router.use(&apos;/view&apos;, function (req, res, next) &#123;</span><br><span class="line">    var path = req.path;</span><br><span class="line">    res.redirect(&apos;https://wk.baidu.com/view&apos; + path + &apos;?st=1#1&apos;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>整个效果就是</p>
<ul>
<li>跳转<a href="https://xxx.xxx.xxx/view/" target="_blank" rel="noopener">https://xxx.xxx.xxx/view/</a>*<ul>
<li>已安装App<ul>
<li>打开App 触发handleUniversalLink</li>
<li>走到/view/分支，拼接阅读页路由</li>
<li>跳转</li>
</ul>
</li>
<li>未安装App<ul>
<li>WebView原地跳转<a href="https://xxx.xxx.xxx/view/" target="_blank" rel="noopener">https://xxx.xxx.xxx/view/</a>*</li>
<li>命中服务器的重定向逻辑</li>
<li>重定向到<a href="https://wk.baidu.com/view/" target="_blank" rel="noopener">https://wk.baidu.com/view/</a>*</li>
<li>打开我们的WAP阅读页<br>这就是为啥明明/_iosuniversallink是完全包含/view能力的，但还是要把/view/单独处理的原因，为的是实现WAP与APP的统一设计，为了通用链接这个初衷<br>不为了统一WAP&amp;APP 只拿来当强化版Schema使用<br>同样的道理，<a href="https://xxx.xxx.xxx/_iosuniversallink/*这个url，也没有实际的页面，如果不进行重定向，也会直接返回404，因此看一眼重定向的代码" target="_blank" rel="noopener">https://xxx.xxx.xxx/_iosuniversallink/*这个url，也没有实际的页面，如果不进行重定向，也会直接返回404，因此看一眼重定向的代码</a><br>router.use(‘/_iosuniversallink’, function (req, res, next) {<br>var redirecturl = ‘<a href="https://wk.baidu.com/topic/naiosappstore&#39;" target="_blank" rel="noopener">https://wk.baidu.com/topic/naiosappstore&#39;</a>;<br>res.redirect(redirecturl);<br>});<br>解释一下<a href="https://wk.baidu.com/topic/naiosappstore就是我们为iOS下载App准备的专门的WAP单页面，这个页面打开后会自动延迟500ms，发起跳转appstore" target="_blank" rel="noopener">https://wk.baidu.com/topic/naiosappstore就是我们为iOS下载App准备的专门的WAP单页面，这个页面打开后会自动延迟500ms，发起跳转appstore</a><br>整个效果就是</li>
</ul>
</li>
</ul>
</li>
<li>跳转<a href="https://xxx.xxx.xxx/_iosuniversallink/" target="_blank" rel="noopener">https://xxx.xxx.xxx/_iosuniversallink/</a>*<ul>
<li>已安装App<ul>
<li>打开App 触发handleUniversalLink</li>
<li>走到/_iosuniversallink/分支，拼接出任意App内的界面路由</li>
<li>跳转界面</li>
</ul>
</li>
<li>未安装App<ul>
<li>WebView原地跳转<a href="https://xxx.xxx.xxx/_iosuniversallink/" target="_blank" rel="noopener">https://xxx.xxx.xxx/_iosuniversallink/</a>*</li>
<li>命中服务器的重定向逻辑</li>
<li>重定向到<a href="https://wk.baidu.com/topic/naiosappstore" target="_blank" rel="noopener">https://wk.baidu.com/topic/naiosappstore</a></li>
<li>naiosappstore页面会延迟跳转AppStore</li>
<li>打开AppStore下载<br>这个设计看起来就是完美解决了PM得需求</li>
</ul>
</li>
</ul>
</li>
<li>如果已安装App，跳转对应界面</li>
<li>如果没安装App，跳转App下载界面<br>解决了旧Schema模式下的弊端问题：</li>
<li>Schema无法判断是否安装App，只能采用setTimeout的Trick方式</li>
<li>Schema的Trick方式会有一个丑陋的错误跳转弹框</li>
<li>Schema无法在微信/手百等App内，打开我们自己的App<br>简单的说，这样设计的初衷就是，我不为了通用链接这一目的来使用Universal Link，来统一WAP&amp;APP的URL跳转，我就为了把Universal Link当做加强版Schema来使用</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/20/数据同步/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="aHuang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="机灵猴">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/20/数据同步/" itemprop="url">数据同步</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-20T21:57:12+08:00">
                2019-03-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="本地持久化方案-和-数据同步"><a href="#本地持久化方案-和-数据同步" class="headerlink" title="本地持久化方案 和 数据同步"></a>本地持久化方案 和 数据同步</h2><p>【 数据持久化 】无论在服务器端和移动端都是非常重要的工作，但是客户端和服务器端持久化的侧重点不同，在服务器端，持久化方案的优劣它直接会在一定程度上影响到APP的性能，然而客户端，只有为数不多的业务需求会涉及持久化方案，而且在大多数情况下，持久化方案对性能的要求并不是特别的苛刻，那么数据持久化它分为内存缓存和磁盘缓存两种：<br><!--阅读全文--></p>
<ul>
<li>内存缓存，内存缓存主要为了节约用户流量，避免相同URL请求多次相同的数据，内存缓存需要根据业务的更新频率和用户请求数据的频率来决定内存缓存数据的有效期。我们可以使用系统方法 NSURLCache，还有优秀的 【 YYCache 】。</li>
<li>磁盘缓存呢就比如说 NSUserDefault 它比较适合应用于那些数据量小而且不太重要的数据，那么对于 账户信息和账户密码等敏感的数据，我们可以用苹果的 Keychain ，它是带有可逆加密的存储机制，普遍用在各种存密码的需求上。另外由于 APP 卸载只要系统不重装， Keychain 中的数据依旧能够得到保留，以及可被 iCloud 同步的特性，大家都会在这里存储用户唯一的标识串。所以对于要加密，要存 iCloud 的敏感的小数据，一般会用 Keychain；一般结构化的数据或者需要方便查询的数据，我都会以 Plist 的方式去持久化，比如《小奶狗记账》的新建账单的支出、收入类型的选择数据/新建账本的选择场景的数据，就是用的本地的 Plist 文件存储的，还有其他一些表单类目的数据。Archive 方式适合存储平时不太经常使用但是数据量又比较大，或者读取之后希望直接对象化的数据，因为 Archive 会将对象及其对象关系序列化，以至于读取数据的时候需要Decode很花时间，Decode 的过程可以是解压，也可以是对象化，这个可以根据具体中的实现来决定。Stream 就是一般的文件存储了，一般用来存存图片，适合比较经常使用，然而数据量又不算非常大的那种；如果我们还希望对数据进行增、删、改、查等操作而且数据的状态和类别会发生变化的时候就比较适合采取数据库的存储方式了。我比较喜欢和常用的数据库是【 LKDBHelper 】，它是对FMDB的封装，实现【 ORM 】面向对象的操作数据库。也可以用系统提供的 CoreData ，但是CoreData被过度封装和设计，以至于不太灵活而且使用非常麻烦相对来说 FMDB更加的灵活和方便可以直接操作数据库。</li>
</ul>
<blockquote>
<p>1、我们做持久化最主要的还是为了解决用户体验的问题，比如说：</p>
</blockquote>
<ul>
<li>在正常网络下，快速提供给用户必要的展示数据，提高APP的用户体验</li>
<li>特别是在网络异常甚至没有网络的情况下，能让应用提供基本的功能</li>
<li>在必要时无网络情况下，用户可以进行必要的操作，在有网络的情况下进行数据同步：比如说我的小奶狗吧，里面的数据都是做了本地持久化的，用的是LKDBHelper；不管是在哪种网络环境下里面的所有功能都可以正常使用，而且会在网络状况良好的时候把做过修改的【 数据同步 】到服务器。</li>
<li>减少对同一个URL的请求次数，甚至只从服务器下载更新过或更改过的资源。节约用户流量，并且也可以减少服务器的压力：比如说图片的加载，用的最多就是 【 SDWebImage 】 了。</li>
<li>确保用户敏感数据的安全<blockquote>
<p>2、除了解决用户体验外，我们作为开发人员还需要注意的一些问题就是代码设计的问题了，比如说：</p>
</blockquote>
</li>
<li>我们的代码设计是否可以长期维护和扩展，对APP的性能是否会产生影响和优化，这个时候 【 CodeReview 】 就非常重要了。（不同需求的缓存目录的选择，数据库的读写隔离，数据库的多线程实现和线程安全，数据库的版本升级和迁移。如果我们的APP是支持多用户切换的话，那么多用户切换时必须要注意数据库的同步和迁移，最后要注意的是用户重要的敏感数据的加密）<blockquote>
<p>参考链接：<a href="http://aes.jypc.org/?p=37540" target="_blank" rel="noopener">http://aes.jypc.org/?p=37540</a></p>
</blockquote>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/16/源码解读/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="aHuang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="机灵猴">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/16/源码解读/" itemprop="url">源码解读</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-16T20:39:24+08:00">
                2019-03-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="YYCache-源码分析"><a href="#YYCache-源码分析" class="headerlink" title="YYCache 源码分析"></a>YYCache 源码分析</h3><p><a href="https://blog.ibireme.com/2015/10/26/yycache/" target="_blank" rel="noopener">https://blog.ibireme.com/2015/10/26/yycache/</a></p>
<h4 id="内存缓存："><a href="#内存缓存：" class="headerlink" title="内存缓存："></a>内存缓存：</h4><p>通常一个缓存是由内存缓存和磁盘缓存组成，内存缓存提供容量小但高速的存取功能，磁盘缓存提供大量但低速的持久化存储。相对于磁盘缓存，内存缓存的设计要更简单些。<br>NSCache 是苹果提供的一个简单的内存缓存，它有着和NSDictionary类似的API，不同的是它是线程安全的，并且不会retain key。线程安全是由pthread_mutex完成的。性能和key的相似度有关，如果有大量相似的key，NSCache 的存取性能会下降的非常厉害，大量的时间被消耗在CFStringEqual() 上；<br>YYMemoryCache 去掉了异步访问的接口，尽量优化了同步访问的性能，用OSSpinLock 来保证线程安全。缓存内部用双向链表和 NSDictionary 实现了 LRU 淘汰算法；<br>YYKit 作者测试结果：<br>YYMemoryCache 的性能仅次于 NSDictionary + OSSpinLock；<br>NSCache 的写入性能稍差，读取性能不错；<br><!--阅读全文--> </p>
<h4 id="磁盘缓存："><a href="#磁盘缓存：" class="headerlink" title="磁盘缓存："></a>磁盘缓存：</h4><p>目前开源的第三方库和一些闭源的实现，包括NSURLCache、Facebook 的 FBDiskCache 等，他们的实现技术大致分为三类：基于文件读写、基于 mmap 文件内存映射、基于数据库；<br>比如 SDWebImage 的缓存是基于文件系统的，即一个value对应一个文件，通过文件读写来缓存数据。缺点：不便扩展，没有元数据，难以实现较好的淘汰算法，数据统计缓慢；<br>FastImageCache 采用的是 mmap 将文件映射到内存。用过 MongoDB 的人应该熟悉 mmap 的缺陷：热数据的文件不要超过物理内存大小，不然 mmap 会导致内存交换严重降低性能；另外内存中的数据时定时 flush 到文件的，如果数据还未同步时程序挂掉，就会导致数据错误。抛开这些缺陷来说，mmap 性能非常高；<br>NSURLCache、FBDiskCache 都是基于 SQLite 数据库的，基于数据库的缓存可以很好的支持元数据、扩展方便、数据统计速度快，也很容易实现LRU 或其他淘汰算法。但是SQLite 读取性能取决于数据大小：当单条数据小于20K时，数据越小 SQLite 读取性能越高；单条数据大于20K时，直接写为文件速度会更快一些。磁盘缓存最好是把SQLite 和文件存储结合起来。<br>YYDiskCache 也是采用的 SQLite 配合文件的存储方式，得益于 SQLite 存储的元数据，YYDiskCache 实现了 LRU 淘汰算法、更快的数据统计，更多的容量控制选项。此处 LRU 是双向链表配合 NSDictionary 实现的，增、删、改、查、清空的时间复杂度都是O（1），这个头文件注释里也有说明。这里的对象释放也是在特定的queue中释放，因为 OC 对象的释放也是比较消耗性能的，作者的目的应该是处于对性能的考虑，把 OC 对象放到子线程中去 release 。作者在《iOS 保持界面流畅的技巧》中提到了这一点。多线程下，QPS（每秒查询率）不会高于单线程，但会降低多少要看具体情况。由于 cache 内部使用锁来保证线程安全的，所以线程数越多、访问竞争越激烈、CPU 资源就消耗越大，QPS 也就越低。当然在实际APP开发中，一般使用时不会遇到这种极端情况。</p>
<h4 id="锁：（YYCache-线程安全的处理）"><a href="#锁：（YYCache-线程安全的处理）" class="headerlink" title="锁：（YYCache 线程安全的处理）"></a>锁：（YYCache 线程安全的处理）</h4><p>ASSpinLock 自旋锁，性能最高的锁。原理比较简单，就是一直 do while 忙等。他的缺点是当等待时会消耗大量的 CPU 资源，所以它不适用于较长时间的任务。对于内存缓存的存取来说，它非常合适；<br>dispatch_senaphonre 是持有计数的信号量，该计数时多线程变成中的技术类型信号。所谓信号，类似于过马路时常用的手旗，可以通过时举起手旗，不可通过时放下手旗。而dispatch_semaphore 使用计数来实现该功能。当信号总量设为 1 时也可以当做锁来看。在没有等待情况出现时，它的性能比 pthread_mutex （互斥锁）还要高，但一旦有等待情况出现时，性能就会下降很多。相对于OSSpinLock 来说，它的优势在于等待时不会消耗 CPU 资源。对磁盘缓存还说，它比较合适。</p>
<!-- ![meinv](../images/meinv.jpg) -->
<h4 id="YYMemoryCache-分层解读："><a href="#YYMemoryCache-分层解读：" class="headerlink" title="YYMemoryCache 分层解读："></a>YYMemoryCache 分层解读：</h4><h5 id="设计思路："><a href="#设计思路：" class="headerlink" title="设计思路："></a>设计思路：</h5><p>系统的 NSCache 读写很快，写入的时候由于 key 的原因稍微慢点，但是对缓存的 totalCostLimit 自动清除缓存却是不可控制的。YYMemoryCache 是对NSCache 进行改造或者站在 NSCache 的设计思路上，进一步提供比较快的写入速度，提供自动清除的可控性。NSDictionary 有 NSCache 一样需要的 key-value 对，读取速度非常快。对于控制清除缓存方面可以写入由时间先后来决定，写入value的时候带上时间并放到一个队列的前面，读取的时候把该 value 放到前面（MRU），清除的时候从最后面开始（LRU）。那么这个队列应该由什么来控制呢？<br>数组内存空间连续，读取速度快，但是修改速度慢，但是现在我们需要的是修改速度比较快的就行了，读取上已经有了 NSDictionary 。链表是修改速度非常快的队列，存储上内存空间不连续。虽然读取的时候慢点，但是我们不需要用它来读取，而且链表也能提供头尾的操作，很符合LRU。所以最终的模式是：NSDictionary + 双线链表 + LRU + （NSCache的线程安全 + 内存警告处理 + 转入后台处理 + 实时 limit 处理）。</p>
<h5 id="封装："><a href="#封装：" class="headerlink" title="封装："></a>封装：</h5><p>交互层，YYMemoryCache.h/m 这个类提供外部的接口，类似于 NSCache。<br>处理层，YYLinkedMap.h/m 这个内部的类来响应交互层的 command，提供数据的读写，删除，也就是双向链表和字典的操作；<br>组件层，YYLinkedMapNode.h/m 这是链表的节点类。<br>LRU 算法原理：<br>用双向链表表示堆栈，新加入的数据存在栈顶，使用缓存的数据的时候，从栈中查找，如果命中，就把数据移到栈顶，可以设置栈最大长度，超过长度就把栈尾的数据删除；</p>
<h5 id="线程安全控制（锁）："><a href="#线程安全控制（锁）：" class="headerlink" title="线程安全控制（锁）："></a>线程安全控制（锁）：</h5><p>（在分析 YYCache 的时候，我发现作者用了很多锁来保证线程的安全。这是值得我学习的地方，因为以前很少考虑过线程安全的问题。）<br>在 YYCache 中主要用了2中锁：pthread_mutex  和 dispatch_semaohore ：pthread_mutex 其实也是利用OSSpinLock 实现的，还有其他的一些锁比如 NSLock、@synchronized 这些使用也很方便，OSSpinLock 相对性能最高，@synchronized 相对性能差些。线程安全就是说多线程访问同一代码，不会产生不确定的结果，如果在执行代码前加锁，只有等这段代码完成后才解锁，这样就不会出现因多线程而出现竞争资源等问题，从而实现线程安全；</p>
<h5 id="双向链表结构："><a href="#双向链表结构：" class="headerlink" title="双向链表结构："></a>双向链表结构：</h5><p>链表的节点（YYLinkedMapNode）：包含上一个节点指针，下一个节点指针，key值，value值，节点开销大小，缓存时间戳等部分；<br>链表（YYLinkedMap）：字典的Ref，链表总开销，链表个数，链表首个节点指针，链表末尾节点指针，是否在主线程释放内存，是否异步释放内存等，链表节点的增、删、改、查等操作。<br>_YYLinkedMapNode <em>node = CFDictionaryGetValue(_lru-&gt;_dic,(__bridge const void </em>)(key)); 这句代码就相当于 NSMutableDictionary objectForKey，取出链表节点，这个 NSMutableDictionary 里面装的是&lt;_YYLinkedMapNode *&gt;；</p>
<h5 id="定时清理："><a href="#定时清理：" class="headerlink" title="定时清理："></a>定时清理：</h5><p>这就是区别普通 NSDictionary 缓存的地方之一，不断在后台更新缓存数据，清理过去数据，只要设置一个_autoTrimInterval 时间间隔就好。这里用了定时器和递归处理；</p>
<h5 id="YYDiskCache-分层解读："><a href="#YYDiskCache-分层解读：" class="headerlink" title="YYDiskCache 分层解读："></a>YYDiskCache 分层解读：</h5><h5 id="YYKVStorage："><a href="#YYKVStorage：" class="headerlink" title="YYKVStorage："></a>YYKVStorage：</h5><p>要解析YYDiskCache 首先得解析 YYKVStorage，该文件主要以2中方式实现磁盘存储：SQLite 和 File，使用2中方式混合进行存储主要为了提高读写效率。写入数据时，SQLite 要比文件的方式更快，读取数据的速度主要取决于文件的大小；据测试，在iPhone 6中，当文件大小超过20kb时，File 要比 SQLite 快的多，所以大文件存储时建议用 File 方式，小文件更适合用 SQLite；所以这里用2中方式混合主要还是考虑到存储的速度；<br>添加数据 saveItemWithKey：… 主要流程是先判断要缓存的数据是否为空，然后判断数据类型，如果是 File 那么久用文件存储的方式进行存储，如果文件存储失败改用 SQLite 进行存储，如果 SQLite 存储也失败，那么久直接删除本地文件存储；如果数据不是 File 类型 那么就直接用 SQLite 方式存储。读取数据的流程与添加数据类似。</p>
<h5 id="YYDiskCache："><a href="#YYDiskCache：" class="headerlink" title="YYDiskCache："></a>YYDiskCache：</h5><p>YYDiskCache 的核心内容就是 YYKVStorage，他是 YYKVStorage 的扩展；</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">aHuang</p>
              <p class="site-description motion-element" itemprop="description">心态在线，激情在线，健康在线，才能创造未来！</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-../images/haha.jpg"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">aHuang</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
