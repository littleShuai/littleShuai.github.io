<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="YYKit是iOS组件的集合，这个框架的代码量很大，这里就分出几个独立的部分。YYModel - iOS高性能模型框架YYCache - iOS高性能缓存框架YYImage - iOS的图像框架用于显示/编码/解码动画WebP，APNG，GIFYYWebImage - 异步图像加载框架YYText - iOS中强大的文本组件YYKeyboardManager - 访问键盘视图并跟踪键盘动画YYDi">
<meta name="keywords" content="littleshuai">
<meta property="og:type" content="article">
<meta property="og:title" content="YYKit源码解析">
<meta property="og:url" content="http://yoursite.com/2019/04/17/YYKit源码解析/index.html">
<meta property="og:site_name" content="机灵猴">
<meta property="og:description" content="YYKit是iOS组件的集合，这个框架的代码量很大，这里就分出几个独立的部分。YYModel - iOS高性能模型框架YYCache - iOS高性能缓存框架YYImage - iOS的图像框架用于显示/编码/解码动画WebP，APNG，GIFYYWebImage - 异步图像加载框架YYText - iOS中强大的文本组件YYKeyboardManager - 访问键盘视图并跟踪键盘动画YYDi">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2019-05-17T04:00:32.149Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="YYKit源码解析">
<meta name="twitter:description" content="YYKit是iOS组件的集合，这个框架的代码量很大，这里就分出几个独立的部分。YYModel - iOS高性能模型框架YYCache - iOS高性能缓存框架YYImage - iOS的图像框架用于显示/编码/解码动画WebP，APNG，GIFYYWebImage - 异步图像加载框架YYText - iOS中强大的文本组件YYKeyboardManager - 访问键盘视图并跟踪键盘动画YYDi">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/04/17/YYKit源码解析/">





  <title>YYKit源码解析 | 机灵猴</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">机灵猴</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">一只调皮的程序媛！</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/17/YYKit源码解析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="aHuang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="机灵猴">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">YYKit源码解析</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-17T09:08:11+08:00">
                2019-04-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>YYKit是iOS组件的集合，这个框架的代码量很大，这里就分出几个独立的部分。<br>YYModel - iOS高性能模型框架<br>YYCache - iOS高性能缓存框架<br>YYImage - iOS的图像框架用于显示/编码/解码动画WebP，APNG，GIF<br>YYWebImage - 异步图像加载框架<br>YYText - iOS中强大的文本组件<br>YYKeyboardManager - 访问键盘视图并跟踪键盘动画<br>YYDispatchQueuePool - iOS实用程序类来管理全局调度队列<br>YYAsyncLayer - 用于异步渲染和显示的iOS实用程序类<br>YYCategories - Foundation和UIKit的一组有用分类。。<br><!--阅读全文--></p>
<p>#pragma mark - UIFont 分类- Create font<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.+ (nullable UIFont *)fontWithCTFont:(CTFontRef)CTFont;</span><br><span class="line"></span><br><span class="line">1.+ (nullable UIFont *)fontWithCGFont:(CGFontRef)CGFont size:(CGFloat)size;</span><br><span class="line"></span><br><span class="line">1.+ (nullable CTFontRef)CTFontRef CF_RETURNS_RETAINED;</span><br><span class="line"></span><br><span class="line">1.+ (nullable CGFontRef)CGFontRef CF_RETURNS_RETSINED;</span><br></pre></td></tr></table></figure></p>
<p>#pragma mark - UIFont 分类- Load and unload font<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.+ (BOOL)loadFontFromPath:(NSString *)path;// 从文件路径加载字体。支持格式：TTF，OTF。如果返回YES，字体可以使用PostScriptName：[UIFont fontWithName：...]进行加载；</span><br><span class="line"></span><br><span class="line">1.+ (void)unloadFontFromPath:(NSString *)path;// 从文件路径中卸载字体</span><br><span class="line"></span><br><span class="line">1.+ (nullable UIFont *)loadFontFromData:(NSData *)data;// 从data加载字体，支持格式：TTF，OTF</span><br><span class="line"></span><br><span class="line">1.+ (BOOL)unloadFontFromData:(UIFont *)font;// 从data写卸载字体</span><br></pre></td></tr></table></figure></p>
<p>#pragma mark - UIFont 分类- Dump font data<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.+ (nullable NSData *)dataFromFont:(UIFont *)font;// 根据UIFont对象，进行序列化，返回NSData类型的数据</span><br><span class="line"></span><br><span class="line">1.+ (nullable NSData *)dataFromCGFont:(CGFontRef)cgFont;// 根据CGFontRef返回一个NSData的数据类型</span><br></pre></td></tr></table></figure></p>
<p>#pragma mark - UIImage分类之框架结构和create image部分</p>
<p>   UIImage框架结构：Create Image，Image Info，Modify Image，Image Effect<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"> + (nullable UIImage *)imageWithSmallGIFData:(NSData *)data scale:(CGFloat)scale</span><br><span class="line"> //根据GIF data对象创建动画图像。在创建之后，你可以通过属性.images获取images，如果data不是动画GIF，这个功能和[UIImage imageWithData:data scale:scale]是一样的；它具有更好的显示性能，但是成本更高（宽高帧字节）。它只适用于显示动画表情符号等小gif。如果你想显示大的GIF，请参阅YYImage；</span><br><span class="line"> </span><br><span class="line"> + (BOOL)isAnimatedGIFData:(NSData *)data;</span><br><span class="line"> // 判断是否data是动画GIF，如果data是GIF并且包含超过一帧就返回YES，否则返回NO；</span><br><span class="line"> </span><br><span class="line"> + (BOOL)isAnimatedGIFFile:(NSString *)path;</span><br><span class="line"> // 判断指定路径的文件是否是GIF；</span><br><span class="line"> </span><br><span class="line"> + (nullable UIImage *)imageWithPDF:(id)dataOrPath;</span><br><span class="line"> //根据PDF文件数据data或者路径创建image，如果PDF有多个页面，则只是返回第一页的内容，图像的比例等于当前屏幕的比例，尺寸与PDF的原始尺寸相同。参数dataOrPath的作用是NSData类型的PDF数据或者NSString类型的文件路径；</span><br><span class="line"> </span><br><span class="line"> + (nullable UIImage *)imageWithPDF:(id)dataOrPath size:(CGSize)size;</span><br><span class="line"> //根据指定的PDF文件数据或者路径创建图像image，如果PDF有多个页面，则只是返回第一页的内容。图像的比例等于当前屏幕的比例，参数size是新图片的大小，PDF的内容将根据需要延展；</span><br><span class="line"> </span><br><span class="line"> + (nullable UIImage *)imageWithEmoji:(NSString *)emoji size:(CGFloat)size;</span><br><span class="line"> //从苹果表情符创建一个方形图像。它从苹果表情符创建一个方形图像，图像比例等于当前屏幕的比例。Apple Color Emoji(比如：@&quot;🌹&quot;)字体中的原始表情符号图像大小为160*160像素；</span><br><span class="line"> </span><br><span class="line"> + (nullable UIImage *)imageWithColor:(UIColor *)color;</span><br><span class="line"> // 用给定的颜色创建并返回1X1点大小的图像</span><br><span class="line"> </span><br><span class="line"> + (nullable UIImage *)imageWithColor:(UIColor *)color size:(CGSize)size;</span><br><span class="line"> // 创建并返回具有给定颜色和大小的纯色图像</span><br><span class="line"> </span><br><span class="line"> + (nullable UIImage *)imageWithSize:(CGSize)size drawBlock:(Void(^)(CGContextRef context))drawBlock;</span><br><span class="line"> // 用自定义绘图代码创建并返回图像，drawBlock里面写需要实现的代码才能真正实现图像；</span><br><span class="line"></span><br><span class="line">[UIImage imageWithSmallGIFData:[NSData data] scale:[UIScreen mainScreen].scale];</span><br><span class="line">[UIImage isAnimatedGIFData:[NSData data]];</span><br><span class="line">[UIImage imageWithPDF:[NSData data]];</span><br><span class="line">UIImage *emojiImage = [UIImage imageWithEmoji:@&quot;🌹&quot; size:160];</span><br></pre></td></tr></table></figure></p>
<p>#pragma mark - UIImage分类之框架结构和create image部分<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)hasAlphaChannel;</span><br><span class="line">判断图像是否有alpha通道。</span><br></pre></td></tr></table></figure></p>
<p>#pragma mark - UIImage分类之框架结构和Modify image部分<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">- (void)drawInRect:(CGRect)rect withContentMode:(UIViewContentMode)contentMode clipsToBounds:(BOOL)clips;</span><br><span class="line">在指定的矩形中绘制整个图像，使用contentMode更改内容。在当前图形上下文中绘制整个图像，并考虑图像的方向设置。在默认坐标系中，图像位于指定矩形的原点的右下方。但是，此方法应用于当前图形上下文的任何转换。</span><br><span class="line"></span><br><span class="line">- (nullable UIImage *)imageByResizeToSize:(CGSize)size;</span><br><span class="line">将原图像进行缩放，图像会根据需要进行延展。</span><br><span class="line"></span><br><span class="line">- (nullable UIImage *)imageByResizeToSize:(CGSize)size contentMode:(UIViewContentMode)contentMode;</span><br><span class="line">将原图像进行缩放，这里会根据指定的contentMode进行缩放</span><br><span class="line"></span><br><span class="line">- (nullable UIImage *)imageByCropToRect:(CGRect)rect;</span><br><span class="line">对图像进行指定大小区域的裁剪</span><br><span class="line"></span><br><span class="line">- (nullable UIImage *)imageByInsetEdge:(UIEdgeInsets)insets withColor:(nullable UIColor *)color;</span><br><span class="line">返回一个图像，该图像是在原图像的基础上缩进或者外扩一定得边距的结果：</span><br><span class="line">insets：内向为正，外向为负</span><br><span class="line">color：边界的填充颜色，如果是nil就是clear color</span><br><span class="line"></span><br><span class="line">- (nullable UIImage *)imageByRoundCornerRadius:(CGFloat)radius;</span><br><span class="line">带一定圆角的图像：radius：每个角落椭圆的半径。大于矩形宽度或高度一半的值将被适当的限制为宽或高的一半；</span><br><span class="line"></span><br><span class="line">- (nullable UIImage *)imageByRoundCornerRadius:(CGFloat)radius borderWidth:(CGFloat)borderWidth borderColor:(nullable UIColor *)borderColor;</span><br><span class="line">获取指定圆角，边线宽度和边界颜色的图像；</span><br><span class="line">radius：圆角大小，大于矩形宽或高的时候，被适当的限制为宽或高的一半；</span><br><span class="line">borderWidth：内边线宽，大于矩形宽或高的时候，被适当的限制为宽或高的一半。</span><br><span class="line">borderColor：边线的颜色，nil表示clear color</span><br><span class="line"></span><br><span class="line">- (nullable UIImage *)imageByRoundCornerRadius:(CGFloat)radius corners:(UIRectCorner)corners borderWidth:(CGFloat)borderWidth borderColor:(nullable UIColor *)borderColor borderLineJoin:(CGLineJoin)borderLineJoin;</span><br><span class="line">获取指定圆角、线宽、线色以及连接类型的图像。</span><br><span class="line"></span><br><span class="line">- (nullable UIImage *)imageByRotate:(CGFloat)radians fitSize:(BOOL)fitSize;</span><br><span class="line">返回一个旋转的图像。</span><br><span class="line">radians：逆时针旋转弧度</span><br><span class="line">fitSize：YES，新图片的大小被扩展到适合所有内容；NO，图片的大小不会改变，内容可能会被裁剪。</span><br><span class="line"></span><br><span class="line">- (nullable UIImage *)imageByRotateLeft90;</span><br><span class="line">逆时针旋转90度，图像和宽高将会交换。</span><br><span class="line"></span><br><span class="line">- (nullable UIImage *)imageByRotateRight90;</span><br><span class="line">右旋转90度，图像宽高将会交换。</span><br><span class="line"></span><br><span class="line">- (nullabel UIImage *)imageByTotate180;</span><br><span class="line">旋转180度。</span><br><span class="line"></span><br><span class="line">- (nullable UIImage *)imageByFlipVertical;</span><br><span class="line">垂直翻转后的图像；</span><br><span class="line"></span><br><span class="line">- (nullable UIImage *)imageByFlipHorizontal;</span><br><span class="line">水平翻转后的图像。</span><br></pre></td></tr></table></figure></p>
<p>#pragma mark - UIImage分类之框架结构和 Image Effect 部分<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">- (UIImage *)imageByTintColor:(UIColor *)color;</span><br><span class="line">用给定颜色在alpha通道中国对图像着色</span><br><span class="line"></span><br><span class="line">- (nullabel UIImage *)imageByGrayscale;</span><br><span class="line">灰度图像；// 用到了OpenGL的相关知识</span><br><span class="line"></span><br><span class="line">- (nullable UIImage *)imageByBlurSoft;</span><br><span class="line">对此图像应用模糊效果，适合模糊任何内容</span><br><span class="line"></span><br><span class="line">- (nullable UIImage *)imageByBlurLight;</span><br><span class="line">对此图像应用模糊效果，适用于模糊除纯白色以外的任何内容；</span><br><span class="line"></span><br><span class="line">- (nullable UIImage *)imageByBlurExtraLight;</span><br><span class="line">对此图像应用模糊效果，适合显示黑色文本。（与ios导航栏白色相同）</span><br><span class="line"></span><br><span class="line">- (nullable UIImage *)imageByBlurDark;</span><br><span class="line">对此图像应用模糊效果，适合显示白色文本，（与iOS通知中心相同）</span><br><span class="line"></span><br><span class="line">- (nullabel UIImage *)imageByBlurWithTint:(UIColor *)tintColor;</span><br><span class="line">对此图像应用模糊和色调颜色</span><br><span class="line"></span><br><span class="line">- (nullable UIImage *)imageByBlurRadius:(CGFloat)blurRadius tintColor:(nullable UIColor *)tintColor tintMode:(CGBlendMode)tintBlendMode saturation:(CGFloat)saturation maskImage:(nullable UIImage *)maskImage;</span><br><span class="line">对此图像应用模糊，色调和饱和度调整，可选地在由maskImage指定区域内；</span><br><span class="line">blurRadius：模糊点的半径，0表示没哟模糊效果；</span><br><span class="line">tintColor：与模糊和饱和度操作的结果均匀混合的可选UIColor对象。这种颜色的alpha通道决定着色的强度。nil意味着没有色彩；</span><br><span class="line">tintBlendMode：混合模式，默认kCGBlendModeNormal</span><br><span class="line">saturation：1.0的值在结果图像不产生变化，小于1.0的值会使得到的图像去饱和，大于1.0的值则会产生相反的效果，0表示灰度；</span><br><span class="line">maskImage：如果指定，则 inputImage仅在由此掩码定义的区域中进行修改。这必须是一个图像掩码，或者它必须满足CGContextClipToMask的掩码参数的要求；</span><br></pre></td></tr></table></figure></p>
<p>#pragma mark - UIImageView分类之架构和image部分<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">UIImageView的基本框架：UIImageView-》image ；UIImageView-》highlight image</span><br><span class="line">这个分类其实和SDWebImage中有关图像下载部分都是类似的；</span><br><span class="line">用到了：runtime，GCD异步线程，线程等待，单列线程，图片缓存和首先从缓存或磁盘中获取已经缓存的图片，如果没有再从网络获取并缓存；整个过程都在异步线程中；</span><br><span class="line"></span><br><span class="line">@property(nullable,nonatomic,strong) NSURL *imageURL;</span><br><span class="line">该属性是当前图像的URL；为此属性设置一个新值将取消先前的请求操作并创建一个新的请求操作来获取图像。设置nil以清除图片和图片URL地址；</span><br><span class="line"></span><br><span class="line">- (void)setImageWithURL:(nullable NSURL *)imageURL placeholder:(nullable UIImage *)placeholder;</span><br><span class="line">就是和SDWebImage一样的；</span><br><span class="line"></span><br><span class="line">- (void)setImageWithURL:(nullabel NSURL *)imageURL options:(YYWebImageOptions)options;</span><br><span class="line">这个方法作用就是下载图像，options下载请求时用到的选项；</span><br><span class="line">YYWebImageManager: 用来创建图像请求操作的管理者；</span><br><span class="line"></span><br><span class="line">- (void)cancelCurrentImageRequest;</span><br><span class="line">取消当前图像下载；</span><br></pre></td></tr></table></figure></p>
<p>#pragma mark - UIImageView分类之架构和highlight image部分<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">与UIImageView分类之架构和image部分类似，不同的是这个是高亮状态；</span><br><span class="line"></span><br><span class="line">- (void)setHignLightedImageWithURL:(nullable NSURL *)imageURL placeholder:(nullable UIImage *)placeHolder;</span><br><span class="line">根据给定的URL设置下载的图片；</span><br><span class="line"></span><br><span class="line">- (void)cancelCurrentHighlightedImageRequest;</span><br><span class="line">取消下载高亮图片；</span><br></pre></td></tr></table></figure></p>
<p>#pragma mark - UIScreen 分类<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">+ (CGFloat)screenScale;</span><br><span class="line">返回屏幕的尺寸比例:GCD</span><br><span class="line"></span><br><span class="line">- (CGRect)currentBounds;</span><br><span class="line">返回当前屏幕的大小: 判断横屏还是竖屏</span><br><span class="line"></span><br><span class="line">- (CGRect)boundsForOrientation:(UIInterfaceOrientation)orientation;</span><br><span class="line">返回给定设备方向的屏幕边界尺寸。UIScreen的bounds方法总是以纵向方向返回它的屏幕边界；</span><br><span class="line"></span><br><span class="line">@property(nonatomic, readonly)CGSize sizeInPixel;</span><br><span class="line">该属性的意义就是屏幕的像素实际尺寸（宽度始终小于高度），该值在未知设备或模拟器中可能不太准确。例如（768，1024）。</span><br><span class="line"></span><br><span class="line">@property(nonatomic,readonly)CGFloat pixelsPerInch;</span><br><span class="line">该属性的作用就是获取每英寸的像素数目，也就是屏幕的PPI，这个值在未知设备和模拟器中可能不是很准确，默认值是96；</span><br></pre></td></tr></table></figure></p>
<p>#pragma mark - UIScrollView 分类<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (void)scrollToTop;</span><br><span class="line">滚动内容到顶部；</span><br><span class="line"></span><br><span class="line">- (void)scrollToBottom;</span><br><span class="line">滚动内容到底部；</span><br><span class="line"></span><br><span class="line">- (void)scrollToLeft;</span><br><span class="line">滚动内容到左侧；</span><br><span class="line"></span><br><span class="line">- (void)scrollToRight;</span><br><span class="line">滚动内容到右侧；</span><br></pre></td></tr></table></figure></p>
<p>#pragma mark - UITableView 分类<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (void)updateWithBlock:(void(^)(UITableView *tableView))block;</span><br><span class="line">执行一系列方法调用，以插入，删除或选择行和部分；如果希望后续插入，删除和选择操作（如cellForRowAtIndexPath：和indexPathsForVisibleRows）同时进行动画，请调用此方法；如果您不在该块内进行插入，删除和选择调用，则table属性（如行数）可能失效。您不应该在块中调用reloaddata；如果您在组中调用此方法，则需要自己执行任何动画。</span><br><span class="line"></span><br><span class="line">- (void)scrollToRow:(NSUInteger)row inSection:(NSUInteger)section atScrollPosition:(UITableViewScrollPosition)scrollPosition animated:(BOOL)animated;</span><br><span class="line">滚动到屏幕指定的行或者section。调用此方法不会导致代理接收scrollViewDidScroll：消息，正如程序调用的用户界面操作一样；</span><br><span class="line"></span><br><span class="line">- (void)insertRow:(NSUInteger)row inSection:(NSUInteger)section withRowAnimation:(UITableViewRowAnimation)animation;</span><br><span class="line">插入一行到指定的位置，可动画；</span><br><span class="line"></span><br><span class="line">- (void)reloadRow:(NSUInteger)row inSection:(NSUInteger)section withRowAnimation:(UITableViewRowAnimation)animation;</span><br><span class="line">使用指定的动画效果刷新指定的行；</span><br></pre></td></tr></table></figure></p>
<p>#pragma mark - UITextField 分类<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (void)selectAllText;</span><br><span class="line">选择所有的文本</span><br><span class="line"></span><br><span class="line">- (void)setSelectedRange:(NSRange)range;</span><br><span class="line">选择指定范围内部的文本</span><br></pre></td></tr></table></figure></p>
<p>#pragma mark - UIView 分类<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">- (nullabel UIImage *)snapshotImage;</span><br><span class="line">创建完整视图层次结构的快照映像</span><br><span class="line"></span><br><span class="line">- (nullabel UIImage *)snapshotImageAfterScreenUpdates:(BOOL)afterUpdates;</span><br><span class="line">创建完整视图层次结构的快照映像，它比snapshotImage快，但可能导致屏幕更新。</span><br><span class="line"></span><br><span class="line">- (nullable NSData *)snapshotPDF;</span><br><span class="line">创建完整视图层次结构的快照PDF；</span><br><span class="line"></span><br><span class="line">- (void)setLayerShadow:(nullable UIColor *)color offset:(CGSize)offset radius:(CGFloat)radius;</span><br><span class="line">设置layer的阴影；</span><br><span class="line"></span><br><span class="line">- (void)removeAllSubviews;</span><br><span class="line">移除所有子视图</span><br><span class="line">注意：不要在view的drawRect: 方法里面调用这个方法。</span><br><span class="line"></span><br><span class="line">@property(nullable,nonatomic,readonly) UIViewController *viewController;</span><br><span class="line">获取view的viewController，可能为nil。</span><br><span class="line"></span><br><span class="line">@property(nonatomic,readonly)CGFloat visibleAlpha;</span><br><span class="line">考虑到父视图和window，返回屏幕上的可见alpha；</span><br><span class="line"></span><br><span class="line">- (CGPoint)convertPoint:(CGPoint)point toViewOrWindow:(nullable UIView *)view;</span><br><span class="line">两个视图上的点的转换。</span><br><span class="line"></span><br><span class="line">- (CGPoint)convertPoint:(CGPoint)point fromViewOrWindow:(nullable UIView *)view;</span><br><span class="line">两个视图上的点的转换，与上面那个方法不同的是，这里是从别的view到receiver的点的转换。</span><br><span class="line"></span><br><span class="line">- (CGRect)convertRect:(CGRect)rect toViewOrWindow:(nullable UIView *)view;</span><br><span class="line">就是两个视图上的rect的转换；</span><br><span class="line"></span><br><span class="line">- (CGRect)convertRect:(CGRect)rect fromViewOrWindow:(nullable UIView *)view;</span><br><span class="line">两个视图上的rect的转换，与上面那个方法不同的是，这里是从别的view到receiver的rect的转换；</span><br></pre></td></tr></table></figure></p>
<p>#pragma mark - UIPasteboard 分类: 粘贴板<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@property(nullable,nonatomic,copy)NSData *PNGData;</span><br><span class="line">获取PNG文件属性；</span><br><span class="line"></span><br><span class="line">@property(nullable,nonatomic,copy)NSData *JPEGData;</span><br><span class="line">获取JPEG文件数据；</span><br><span class="line"></span><br><span class="line">@property(nullable,nonatomic,copy)NSData *GIFData;</span><br><span class="line">获取GIF文件数据；</span><br><span class="line"></span><br><span class="line">@property(nullable,nonatomic,copy)NSData *WEBPData;</span><br><span class="line">获取webp文件数据；</span><br><span class="line"></span><br><span class="line">@property(nullable,nonatomic,copy) NSData *imageData;</span><br><span class="line">获取图像文件数据。</span><br><span class="line"></span><br><span class="line">@property(nullable,nonatomic,copy)NSAttributedString *attributedString;</span><br><span class="line">设置此属性还将设置属性字符串中的字符串属性，如果属性字符串包含一个或多个图像，它也会设置images属性；</span><br></pre></td></tr></table></figure></p>
<p>#pragma mark - UIGestureRecognizer 分类<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)initWithActionsBlock:(void(^)(id sender))block;</span><br><span class="line">用action块初始化已分配的手势识别器对象；block：处理接收器识别的手势action块，nil无效，它由手势保留；返回值为具体UIGestureRecognizer子类的初始化实例，如果尝试初始化对象时发生错误，则为nil。</span><br><span class="line">用到了runtime的思想；</span><br><span class="line"></span><br><span class="line">- (void)addActionBlock:(void(^)(id sender))block;</span><br><span class="line">为手势对象添加actionBlock，它由手势保留；</span><br><span class="line"></span><br><span class="line">- (void)removeAllActionBlocks;</span><br><span class="line">移除所有的动作块；</span><br></pre></td></tr></table></figure></p>
<p>#pragma mark - UIDevice分类框架 及 Device Information<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">UIDevice 分类的框架：Device Information，Network Information，Disk Space，CPU Information，Memory Information。</span><br><span class="line">+ (double)systemVersion;</span><br><span class="line">返回系统的版本；</span><br><span class="line"></span><br><span class="line">@property(nonatomic,readonly)BOOL isPad;</span><br><span class="line">判断设备是否是iPad和iPad mini；</span><br><span class="line"></span><br><span class="line">@property(nonatomic,readonly)BOOL isSimulator;</span><br><span class="line">判断设备是否是模拟器；</span><br><span class="line"></span><br><span class="line">@property(nonatomic,readonly)BOOL isJailbroken;</span><br><span class="line">判断设备是否是越狱机；</span><br><span class="line"></span><br><span class="line">@property(nonatomic,readonly)BOOL canMakePhoneCalls;</span><br><span class="line">判断是否可以打电话；</span><br><span class="line"></span><br><span class="line">@property(nullable,nonatomic,readonly)NSString *machineModel;</span><br><span class="line">判断机型，比如“iPhone6,1”&quot;iPad4,6&quot;.</span><br><span class="line"></span><br><span class="line">@property(nullable,nonatomic,readonly)NSString *machineModelName;</span><br><span class="line">用来判断机型名称，比如&quot;iPhone 5s&quot;,&quot;iPad mini 2&quot;</span><br><span class="line"></span><br><span class="line">@property(nonatomic,readonly)NSDate *systemUptime;</span><br><span class="line">获取系统开始时间: 上次启动时间</span><br></pre></td></tr></table></figure></p>
<p>#pragma mark - UIDevice分类框架及Network Information<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@property(nullable,nonatomic,readonly)NSString *ipAddressWIFI;</span><br><span class="line">获取设备的WIFI IP地址，例如：192.168.1.111</span><br><span class="line"></span><br><span class="line">@property(nullable,nonatomic,readonly)NSString *ipAddressCell;</span><br><span class="line">设备的cell ip地址，例如：@&quot;10.2.2.222&quot;</span><br><span class="line"></span><br><span class="line">枚举 YYNetworkTrafficType</span><br><span class="line">WWAN：Wireless Wide Area Network ，For Example： 3G/4G</span><br><span class="line">WIFI：wi-fi</span><br><span class="line">AWDL：Apple Wireless Direct Link （peer-to-peer connection）for example：AirDrop，AirPlay，GameKit。</span><br><span class="line"></span><br><span class="line">- (uint64_t)getNetworkTrafficBytes:(YYNetworkTrafficType)types;</span><br><span class="line">获取设备网络流量字节，这是自设备上次启动以来的计数器。</span><br><span class="line">GCD: dispatch_semaphore_t 线程锁</span><br></pre></td></tr></table></figure></p>
<p>#pragma mark - UIDevice分类框架及 Disk Space<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@property(nonatomic,readonly)int64_t diskSpace;</span><br><span class="line">获取设备的磁盘空间；</span><br><span class="line"></span><br><span class="line">@property(nonatomic,readonly)int64_t diskSpaceFree;</span><br><span class="line">获取设备的可用磁盘空间；</span><br><span class="line"></span><br><span class="line">@property(nonatomic,readonly)int64_t diskSpaceUsed;</span><br><span class="line">获取设备使用的空间;</span><br></pre></td></tr></table></figure></p>
<p>#pragma mark - UIDevice分类框架及 Memory Information<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@property(nonatomic,readonly)int64_t memoryTotal;</span><br><span class="line">获取设备的内存总量；</span><br><span class="line"></span><br><span class="line">@property(nonatomic,readonly)int64_t memoryUsed;</span><br><span class="line">获取设备使用的内存总量；</span><br><span class="line"></span><br><span class="line">@property(nonatomic,readonly)int64_t memoryFree;</span><br><span class="line">获取设备可用的内存总量。</span><br><span class="line"></span><br><span class="line">@property(nonatomic,readonly)int64_t memoryActive;</span><br><span class="line">获取设备活动内存；</span><br><span class="line"></span><br><span class="line">@property(nonatomic,readonly)int64_t memoryInactive;</span><br><span class="line">获取设备非活动内存</span><br><span class="line"></span><br><span class="line">@property(nonatomic,readonly)int64_t memoryWired;</span><br><span class="line">获取设备的wired memory。</span><br><span class="line"></span><br><span class="line">@property(nonatomic,readonly)int64_t memoryPurgable;</span><br><span class="line">获取设备purgable memory；</span><br></pre></td></tr></table></figure></p>
<p>#pragma mark - UIDevice分类框架及 CPU Information<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@property(nonatomic,readonly)NSUInteger cpuCount;</span><br><span class="line">获取当前的进程数；</span><br><span class="line"></span><br><span class="line">@property(nonatomic,readonly)float cpuUsage;</span><br><span class="line">获取CPU使用率，1.0代表100%；</span><br><span class="line"></span><br><span class="line">@property(nonatomic,readonly)NSArray&lt;NSNumber *&gt; *cpuUsagePerProcessor;</span><br><span class="line">获取每个进程对应的CPU使用，1.0 代表100%；</span><br></pre></td></tr></table></figure></p>
<p>#pragma mark - UIControl 分类<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (void)removeAllTargets;</span><br><span class="line">从一个内部的dispatch table中移除某一特定event的所有的targets和actions。</span><br><span class="line">注册的事件，不进已经被加入到事件当中，会被识别，，同时，将信息注入到列表，可被查询，可被修改。</span><br><span class="line"></span><br><span class="line">- (void)setTarget:(id)target action:(SEL)action forControlEvents:(UIControlEvents)controlEvents;</span><br><span class="line">为某一特定的event添加或者移除target和action到一个内部dispatch table。</span><br><span class="line">target：目标对象-即消息发送到的对象，如果这是nil，响应者链会搜索一个愿意回应该动作消息的对象；</span><br><span class="line">action：一个标识动作消息的选择器，它不能为NULL；</span><br><span class="line">controlEvents：指定发送操作消息的控件事件的位掩码；</span><br><span class="line"></span><br><span class="line">- (void)addBlockForControlEvents:(UIControlEvents)controlEvents block:(void(^)(id sender))block;</span><br><span class="line">将特定事件（或事件）的块添加到内部dispatch table 中。它会引起对@a block 的强引用；</span><br><span class="line"></span><br><span class="line">- (void)setBlockForControlEvents:(UIControlEvents)controlEvents block:(void(^)(id sender))block;</span><br><span class="line">将特定事件（或事件）的块添加或替换到内部dispatch table中。它会引起对@a block的强烈引用。</span><br><span class="line">block：当action消息被发送时调用block（不能为nil），该块被引用。</span><br><span class="line">controlEvents：指定发送操作消息的控件事件的位掩码</span><br><span class="line"></span><br><span class="line">- (void)removeAllBlocksForControlEvents:(UIControlEvents)controlEvents;</span><br><span class="line">将内部dispatch table中特定事件或事件的所有block移除；</span><br><span class="line">controlEvents：指定发送操作消息的控件事件的位掩码；</span><br></pre></td></tr></table></figure></p>
<p>#pragma mark - UIColor 分类 之Create a UIColor Object<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">该分类的框架结构：Create a UIColor Object，Get Color’s description，Retrieving Color Information。</span><br><span class="line"></span><br><span class="line">+ (UIColor *)colorWithHue:(CGFloat)hue saturation:(CGFloat)saturation lightness:(CGFloat)lightness alpha:(CGFloat)alpha;</span><br><span class="line">使用指定的不透明度和HSL颜色空间分量值创建并返回一个颜色对象；</span><br><span class="line">hue：HSL颜色空间的颜色对象的hue分量，值为0.0-1.0；</span><br><span class="line">saturation：HSL颜色空间的颜色对象的saturation：HSL分量，值为0.0-1.0；</span><br><span class="line">lightness：HSL颜色空间的颜色对象的lightness：HSL分量，值为0.0-1.0；</span><br><span class="line">alpha：不透明度，0.0-1.0之间；</span><br><span class="line"></span><br><span class="line">+ (UIColor *)colorWithCyan:(CGFloat)cyan magenta:(CGFLoat)magenta yellow:(CGFloat)yellow black:(CGFLoat)black alpha:(CGFloat)alpha;</span><br><span class="line">使用指定的不透明度和CMYK颜色空间分量值创建并返回一个颜色对象；值：0.0-1.0</span><br><span class="line">返回值为RGB颜色空间的颜色对象；</span><br><span class="line"></span><br><span class="line">+ (nullable UIColor *)colorWithHexString:(NSString *)hexStr;</span><br><span class="line">根据指定的hex 字符串创建并返回颜色对象。</span><br><span class="line"></span><br><span class="line">+ (UIColor *)colorByAddColor:(UIColor *)add blendMode:(CGBlendMode)blendMode;</span><br><span class="line">在原来颜色的基础上，混入新的颜色，并根据混合模式创建新的颜色对象；</span><br></pre></td></tr></table></figure></p>
<p>#pragma mark - UIButton 分类 之 image<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">框架结构：image，backgroundImage</span><br><span class="line">- (nullabel NSURL *)imageURLForState:(UIControlState)state;</span><br><span class="line">返回按钮指定状态的URL地址；还是用到了runtime,GCD,缓存 的方法；</span><br><span class="line"></span><br><span class="line">- (void)setImageWithURL:(nullable NSURL *)imageURL forState:(UIControlState)state placeholder:(nullable UIImage *)placeholder;</span><br><span class="line">给按钮设置指定URL地址的图像；</span><br><span class="line"></span><br><span class="line">- (void)cancelImageRequestForState:(UIControlState)state;</span><br><span class="line">取消当前图像对指定状态的请求；</span><br></pre></td></tr></table></figure></p>
<p>#pragma mark - UIButton 分类 之 backgroundImage<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (void)backgroundImageURLForState:(UIControlState)state;</span><br><span class="line"></span><br><span class="line">- (void)setBackgroundImageWithURL:(nuallbel NSURL *)imageURL forState:(UIControlState)state placeholder:(nullabel UIImage *)placeholder;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">跟image 实现方法是一样的；</span><br></pre></td></tr></table></figure></p>
<p>#pragma mark - UIBezierPath 分类<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ (nullabel UIBezierPath *)bezierPathWithText:(NSString *)text font:(UIFont *)font;</span><br><span class="line">创建并返回一个新的UUIBezierPath对象，该对象使用从指定字体生成的文本字形进行初始化；</span><br><span class="line">它不支持苹果表情符号，如果你想获得表情符号图片，请尝试使用UIImage（YYAdd）中的[UIImage imageWithEmoji:size:].</span><br></pre></td></tr></table></figure></p>
<p>#pragma mark - UIBarButtonItem 分类<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@property(nullabel,nonatomic,copy)void(^actionBlock)(id);</span><br><span class="line">当Item被选择的时候调用这个block，block捕获的对象将被buttonItem持有；</span><br><span class="line">这个参数与target 和 action属性冲突，设置这个，将会对内部对象的target 和 action属性进行设置；</span><br></pre></td></tr></table></figure></p>
<p>#pragma mark - UIApplication 分类<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">@property(nonatomic,readonly)NSURL *documentsURL;</span><br><span class="line">获取documents的文件目录；</span><br><span class="line"></span><br><span class="line">@property(nonatomic,readonly)NSString *documentsPath;</span><br><span class="line">获取documents的文件目录；</span><br><span class="line"></span><br><span class="line">@property(nonatomic,readonly)NSURL *cachesURL;</span><br><span class="line">获取cache的文件目录；</span><br><span class="line"></span><br><span class="line">@property(nonatomic,readonly)NSString *cachesPath;</span><br><span class="line">获取cache的文件目录；</span><br><span class="line"></span><br><span class="line">@property (nonatomic, readonly) NSURL *libraryURL;</span><br><span class="line">这个属性的作用就是获取library的文件目录。</span><br><span class="line"></span><br><span class="line">@property (nonatomic, readonly) NSString *libraryPath;</span><br><span class="line">这个属性的作用就是获取library的文件目录。</span><br><span class="line"></span><br><span class="line">@proprty(nullabel,nonatomic,readonly)NSString *appBundleName;</span><br><span class="line">获取APPlication‘s bundle name</span><br><span class="line"></span><br><span class="line">@property(nonatomic,readonly)BOOL isPirated;</span><br><span class="line">判断是否是盗版的，也就是不是从apple store中下载的；</span><br><span class="line">如果有人真的想破解你的应用程序，这个方法是没用的。</span><br><span class="line">您可以更改此方法的名称、加密代码并进行更多检查</span><br><span class="line"></span><br><span class="line">@property(nonatomic,readonly)BOOL isBeingDebugged;</span><br><span class="line">判断是不是正在调试；</span><br><span class="line"></span><br><span class="line">+ (BOOL)isAppExtension;</span><br><span class="line">如果是APPExtension就返回YES；</span><br><span class="line"></span><br><span class="line">+ (nullabel UIApplication *)sharedExtensionApplication;</span><br><span class="line">与shareApplication相同，但在APP Extension中返回你nil；</span><br><span class="line"></span><br><span class="line">- (void)incrementNetworkActivityCount;</span><br><span class="line">增加活动网络请求的数量，如果此数字在增量之前为0，则会启动状态栏网络活动指示器的动画，这个方法是线程安全的。并对APP Extension没有影响；</span><br><span class="line"></span><br><span class="line">- (void)decrementNetworkActivityCount;</span><br><span class="line">减少活动网络请求的数量。如果此数字在递减后变为0，则会停止为状态栏网络活动指示器设置动画，这个方法是线程安全的，并对APP Extension没有影响；</span><br></pre></td></tr></table></figure></p>
<p>#pragma mark - NSTimer 分类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+ (NSTimer *)scaheduledTimerWithTimeinterval:(NSTimeInterval)seconds block:(void(^)(NSTimer *timer))block repeats:(BOOL)repeats;</span><br><span class="line">创建并返回一个NSTimer对象，并将它调度到default mode模式的runloop中；</span><br><span class="line"></span><br><span class="line">+ (NSTimer *)timerWithTimeInterval:(NSTimeInterval)seconds block:(void (^)(NSTimer *timer))block repeats:(BOOL)repeats;</span><br><span class="line">创建并返回一个NSTimer对象，这个方法和上面那个的区别就是这个需要自己放到runloop中；</span><br></pre></td></tr></table></figure></p>
<p>#pragma mark - NSParagraphStyle 分类<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+ (nullable NSParagraphStyle *)styleWithCTStyle:(CTParagraphStyleRef)CTStyle;</span><br><span class="line">根据CTParagraphStyleRef创建新的NSParagraphStyle对象；</span><br></pre></td></tr></table></figure></p>
<p>#pragma mark - NSObject 分类 之YYModel<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">如果默认的模型转换不能适合你的模型类，实现协议中的一个或者更多的方法来改变默认的键值转换过程，不用在你的类的头文件中添加&lt;YYModel&gt;；</span><br><span class="line">+ (nullable NSDictionary&lt;NSString *,id&gt; *)modelCustomPropertyMapper;</span><br><span class="line">如果JSON/NSDictionary中的key不能匹配模型中属性的名字，实现这个方法并返回映射；</span><br><span class="line"></span><br><span class="line">+ (nullable NSDictionary&lt;NSString *,id&gt; *)modelContainerPropertyGenericClass;</span><br><span class="line">容器属性的泛型类映射器。如NSArray，NSSet，NSDictionary，实现此方法并返回一个property-》class映射器，告诉哪种对象将被添加到array，set，dictionary。</span><br><span class="line"></span><br><span class="line">+ (nullable Class)modelCustomClassForDictionary:(NSDictionary *)dictionary;</span><br><span class="line">如果你需要在json-》Object转换过程中创建不同类的示例，使用该方法根据字典数据选择自定义类；</span><br><span class="line"></span><br><span class="line">+ (nullable NSArray&lt;NSString *&gt; *)modelPropertyBlacklist;</span><br><span class="line">在模型转换过程中，所有黑名单中的属性将被忽略，返回值就是一组属性名称；</span><br><span class="line"></span><br><span class="line">+ (nullabel NSArray&lt;NSString *&gt; *)modelPropertyWhitelist;</span><br><span class="line">如果属性不在白名单中，它将在模型转换过程中被忽略。</span><br><span class="line"></span><br><span class="line">+ (nullable NSArray *)modelArrayWithClass:(Class)cls json:(id)json;</span><br><span class="line">从json-array创建并返回一个数组；</span><br><span class="line"></span><br><span class="line">+ (nullabel NSDictionary *)modelDictionaryWithClass:(Class)cls json:(id)json;</span><br><span class="line">从json创建并返回一个字典；</span><br><span class="line"></span><br><span class="line">+ (nullabel instancetype)modelWithJson:(id)json;</span><br><span class="line">从json创建并返回一个实例，该方法是线程安全的；</span><br><span class="line"></span><br><span class="line">+ (nullable instancetype)modelWithDictionary:(NSDictionary *)dictionary;</span><br><span class="line">从字典创建并返回一个实例，该方法是线程安全的；这里注意，在给对象的属性进行赋值的时候，如果值类型和属性类型不符合的话，该方法会按照下面规则进行适当的转换；</span><br><span class="line">`NSString` or `NSNumber` -&gt; c number, such as BOOL, int, long, float, NSUInteger...</span><br><span class="line">`NSString` -&gt; NSDate, parsed with format &quot;yyyy-MM-dd&apos;T&apos;HH:mm:ssZ&quot;, &quot;yyyy-MM-dd HH:mm:ss&quot; or &quot;yyyy-MM-dd&quot;.</span><br><span class="line">`NSString` -&gt; NSURL.</span><br><span class="line">`NSValue` -&gt; struct or union, such as CGRect, CGSize, ...</span><br><span class="line">`NSString` -&gt; SEL, Class.</span><br><span class="line"></span><br><span class="line">- (BOOL)modelSetWithJSON:(id)json;</span><br><span class="line">判断model和json之间的转换是否成功；</span><br><span class="line"></span><br><span class="line">- (BOOL)modelSetWithDictionary:(NSDictionary *)dic;</span><br><span class="line">用给定的字典设置接受者的属性；字典中的key会映射到接受者的属性名称上，值将被设置给属性，如果值类型和属性类型不相符，这个方法将会按照下面的规则进行转换；</span><br><span class="line">`NSString` or `NSNumber` -&gt; c number, such as BOOL, int, long, float, NSUInteger...</span><br><span class="line">`NSString` -&gt; NSDate, parsed with format &quot;yyyy-MM-dd&apos;T&apos;HH:mm:ssZ&quot;, &quot;yyyy-MM-dd HH:mm:ss&quot; or &quot;yyyy-MM-dd&quot;.</span><br><span class="line">`NSString` -&gt; NSURL.</span><br><span class="line">`NSValue` -&gt; struct or union, such as CGRect, CGSize, ...</span><br><span class="line">`NSString` -&gt; SEL, Class.</span><br><span class="line"></span><br><span class="line">- (nullable id)modelToJSONObject;</span><br><span class="line">根据接受者属性生成一个json对象；如果接受者是NSArray，NSDictionary or NSSet，那么它仅将内部对象转化为json对象；</span><br><span class="line"></span><br><span class="line">- (nullabel NSData *)modelToJSONData;</span><br><span class="line">根据接受者属性生成一个json data；如果接受者是NSArray，NSDictionary，NSSet，那么它仅将内部对象转化为json字符串；</span><br><span class="line"></span><br><span class="line">- (nullabel NSString *)modelToJSONString;</span><br><span class="line">根据接受者属性，生成一个json字符串；</span><br><span class="line"></span><br><span class="line">- (nullable id)modelCopy;</span><br><span class="line">根据接受者属性，生成一个实例；</span><br><span class="line"></span><br><span class="line">- (void)modelEncodeWithCoder:(NSCoder *)aCoder;</span><br><span class="line">将接受者属性编码到coder；</span><br><span class="line"></span><br><span class="line">- (id)modelInitWithCoder:(NSCoder *)aDecoder;</span><br><span class="line">将接受者属性进行解码；</span><br><span class="line"></span><br><span class="line">- (NSUInteger)modelHash;</span><br><span class="line">获取接受者属性的hash code；</span><br><span class="line"></span><br><span class="line">- (NSString *)modelDescription;</span><br><span class="line">返回接受者内容的描述字符串；</span><br></pre></td></tr></table></figure></p>
<p>#pragma mark - NSObject 分类 之 KVO<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (void)addObserverBlockForKeyPath:(NSString *)keyPath block:(void(^)(id _Nonnull obj,_Nullable id oldVal,_Nullable id newVal))block;</span><br><span class="line">该方法的作用就是根据接受者指定的key-path注册block接收KVO通知；block和block捕获的对象都被引用，调用removeObserverBlocksForKeyPath：或者removeObserverBlocks进行释放；block：注册KVO通知的block；</span><br><span class="line"></span><br><span class="line">- (void)removeObserverBlocksForKeyPath:(NSString *)keyPath;</span><br><span class="line">对于指定的key-path指定的属性，停止所有接收改变的通知的所有block（通过addObserverBlockForKeyPath：block：指派）；</span><br><span class="line"></span><br><span class="line">- (void)removeObserverBlocks;</span><br><span class="line">停止所有的block（由addObserverBlockForKeyPath：block：指派）接收更改的通知，并释放这些block；</span><br></pre></td></tr></table></figure></p>
<p>#pragma mark - NSObject 分类 之 Sending messages with variable parameters<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">框架结构;Sending messages with variable parameters（可变变量）,swap method(交换方法)，Associate value(关联属性)</span><br><span class="line"> </span><br><span class="line"> - (nullable id)performSelectorWithArgs:(SEL)sel,...;</span><br><span class="line"> 想receiver发送指定的消息，并返回消息的结果；</span><br><span class="line"> sel：一个标识要发送消息的selector，如果selector是NULL或者不识别的，会抛出NSInvalidArgumentException；</span><br><span class="line"> ...：变量参数列表，参数类型必须和selector方法声明的类型一致，否则可能导致不期望的错误，它不支持大于256bytes的union或者struct。</span><br><span class="line"> 如果selector的返回类型不是对象，selector的返回值将被包装为NSNumber or NSValue；如果selector的返回类型是void那么就会返回nil；</span><br><span class="line"> 列：</span><br><span class="line"></span><br><span class="line"> NSData *data = [NSData dataWithContentsOfURL:[NSURL URLWithString:testURL()]];</span><br><span class="line"> UIImage *image = [UIImage.class performSelectorWithArgs:@selector(imageWithData:scale:),data,2.0];</span><br><span class="line"> UIImage *image1 = [UIImage imageWithData:data scale:2.0];</span><br><span class="line"> 这两个方法是一样的意思：</span><br><span class="line"> 区别：调用路径不一样：performSelector 先去寻找对应IMP，速度更快，不过写法变得相对没有那么安全；直接调用，走runtime；</span><br><span class="line"> </span><br><span class="line"> - (void)performSelectorWithArgs:(SEL)sel afterDelay:(NSTimeInterval)delay,...;</span><br><span class="line"> 延迟一定时间后，使用默认模式在当前线程上调用receiver的方法；</span><br><span class="line"> 注意：不能通过先前的request取消；</span><br><span class="line"> sel：一个指定要发送消息的selector，如果selector是NULL或者无法识别，那么就会引起错误NSInvalidArgumentException。</span><br><span class="line"> delay：在消息被发出前的最小时间，指定为0并不能保证立即执行，selector仍然会在线程run loop中进行排队，并会尽快执行；</span><br><span class="line"> ...：变量参数列表，参数类型必须和selector方法声明类型一致，否则会引起无法预期的错误，不支持大于256 bytes的union或者struct。</span><br><span class="line"> </span><br><span class="line"> - (nullable id)performSelectorWithArgsOnMainThread:(SEL)sel waitUntilDone:(BOOL)wait,...;</span><br><span class="line"> 使用default mode 在主线程中调用receiver的方法；</span><br><span class="line"> wait：一个BOOL值，指定当前线程是否阻塞直到在指定的线程执行完指定的selector，指定为YES阻塞这个线程，否则表示立即返回；如果selector的返回类型不是对象，那么返回结果被包装为NSNumber or NSValue，如果selector的返回类型是void，那么wait就是YES。</span><br></pre></td></tr></table></figure></p>
<p>#pragma mark - NSObject分类之Swap method (Swizzling)<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">埋点统计，基类，有点类似服务器端的域名重定向；</span><br><span class="line"></span><br><span class="line">+ (BOOL)swizzleInstanceMethod:(SEL)originalSel with:(SEL)newSel;</span><br><span class="line">交换一个类中两个对象方法：</span><br><span class="line"></span><br><span class="line">+ (BOOL)swizzleClassMethod:(SEL)orginalSel with:(SEL)newSel;</span><br><span class="line">交换一个类中的了两个类方法。</span><br></pre></td></tr></table></figure></p>
<p>#pragma mark - NSObject分类之 Associate Value<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">- (void)setAssociateValue:(nullable id)value withKey:(void *)key;</span><br><span class="line">将self和一个对象关联，起到类似strong修饰的属性的作用；动态增加对象属性并赋值，取值时也要用动态取值getAssociatedValueForKey:方法；</span><br><span class="line"></span><br><span class="line"> - (void)setAssociateWeakValue:(nullable id)value withKey:(void *)key;</span><br><span class="line">动态增加对象属性并赋值，起到类似weak修饰的属性的作用。</span><br><span class="line"></span><br><span class="line">- (void)removeAssociatedValues;</span><br><span class="line">移除所有关联的值。</span><br><span class="line"></span><br><span class="line">UIFont *font = [[UIFont alloc]init];</span><br><span class="line">id font1 = [font deepCopy];</span><br><span class="line">[font setAssociateValue:@&quot;asso&quot; withKey:@&quot;fontName&quot;];</span><br><span class="line">NSLog(@&quot;fontName: %@&quot;,[font getAssociatedValueForKey:@&quot;fontName&quot;]);</span><br><span class="line">[font setAssociateWeakValue:@&quot;14&quot; withKey:@&quot;fontSize&quot;];</span><br><span class="line">[font getAssociatedValueForKey:@&quot;fontSize&quot;];</span><br><span class="line">[font removeAssociatedValues];</span><br><span class="line"></span><br><span class="line">BillHomeModel *model = [[BillHomeModel alloc]init];</span><br><span class="line">model.name = @&quot;lily&quot;;</span><br><span class="line">model.imageURL = testURL();</span><br><span class="line">[model addObserverBlockForKeyPath:@&quot;name&quot; block:^(id  _Nonnull obj, id  _Nullable oldVal, id  _Nullable newVal) &#123;</span><br><span class="line">NSLog(@&quot;obj:%@---old:%@----new:%@&quot;,obj,oldVal,newVal);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[model setAssociateValue:@&quot;qian&quot; withKey:@&quot;asso&quot;];</span><br><span class="line">[model getAssociatedValueForKey:@&quot;asso&quot;]&apos;</span><br><span class="line">model.name = @&quot;Josh&quot;;</span><br><span class="line">model.name = @&quot;Bella&quot;;</span><br><span class="line">[model removeObserverBlocksForKeyPath:@&quot;name&quot;];</span><br><span class="line">[model removeObserverBlocks];</span><br></pre></td></tr></table></figure></p>
<p>#pragma mark - NSObject分类之 Other<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+ (NSString *)className;</span><br><span class="line">返回类名的NSString形式；</span><br><span class="line"></span><br><span class="line">- (NSString *)className;</span><br><span class="line">返回类名的NSString形式；</span><br><span class="line"></span><br><span class="line">- (nullable id)deepCopy;</span><br><span class="line">返回NSKeyedArchiver 和 NSKeyedUnarchiver示例对象的副本；</span><br><span class="line">深拷贝是指将整个对象内存直接拷贝到另一块内存中，浅拷贝（shallow copy）仅仅拷贝指向对象的指针，即浅拷贝是指针拷贝，深拷贝是内容拷贝，实现深拷贝的方法，可以先将对象归档后再进行解档，通过归档后解档获取内容一致的集合，并且该集合又存在另一块内存上，互不影响。</span><br></pre></td></tr></table></figure></p>
<p>#pragma mark - NSNotificationCenter 分类<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (void)postNotificationOnMainThread:(NSNotification *)notification;</span><br><span class="line">在主线程中发送通知，如果当前线程是主线程，那么就同步发送通知，如果当前线程不是主线程，异步发送通知；</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>#pragma mark - NSKeyedUnarchiver 分类<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (nullable id)unarchiveObjectWithData:(NSData *)</span><br></pre></td></tr></table></figure></p>
<p>#pragma mark - NSDictionary 分类 之 dictionary convertor（转化器）<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">NSDictionary框架结构：Dictionary convertor，dictionary value center，NSMutableDictionary；</span><br><span class="line">+ (nullable NSDictionary *)dictionaryWithPlistData:(NSData *)plist;</span><br><span class="line">将指定的plist数据转化为一个字典；</span><br><span class="line"></span><br><span class="line">+ (nullable NSDictionary *)dictionaryWithPlistStirng:(NSString *)plist;</span><br><span class="line">将指定的property list xml 字符串转化为一个字典；</span><br><span class="line"></span><br><span class="line">- (nullable NSData *)plistData;</span><br><span class="line">将字典序列化一个binary property list data；</span><br><span class="line"></span><br><span class="line">- (nullable NSString *)plistString;</span><br><span class="line">将字典序列化一个xml property list 字符串；</span><br><span class="line"></span><br><span class="line">- (NSArray *)allKeysSorted;</span><br><span class="line">将字典的所有key查出来，并且在数组中按照升序进行排列,key必须是NSString类型的；</span><br><span class="line"></span><br><span class="line">- (NSArray *)allValuesSortedByKeys;</span><br><span class="line">返回key对应的值，并数组中的值是按找keys的升序排列的；</span><br><span class="line"></span><br><span class="line">- (BOOL)containsObjectForKey:(id)key;</span><br><span class="line">判断字典是否有指定key对应的value。</span><br><span class="line"></span><br><span class="line">- (NSDictionary *)entriesForKeys:(NSArray *)keys;</span><br><span class="line">返回keys对应的新的字典: 查找keys对应的values，并将这些keys和values组装成新的字典；</span><br><span class="line"></span><br><span class="line">- (nullable NSString *)jsonStringEncoded;</span><br><span class="line">将字典转化为json字符串；</span><br><span class="line"></span><br><span class="line">- (nullable NSString *)jsonPrettyStringEncoded;</span><br><span class="line">将字典转化为json字符串格式；</span><br><span class="line"></span><br><span class="line">+ (nullable NSDictionary *)dictionaryWithXML:(id)xmlDataOrString;</span><br><span class="line">尝试解析xml并将其包装到字典中，如果你只是想从一个小的xml获取一些价值，试试这个方法；</span><br><span class="line"></span><br><span class="line">NSString *path = [[NSBundle mainBundle] pathForResource:@&quot;YYKPlist&quot; ofType:@&quot;plist&quot;];</span><br><span class="line">NSData *plistD = [NSData dataWithContentsOfFile:path];</span><br><span class="line">NSDictionary *dic = [NSDictionary dictionaryWithPlistData:plistD];</span><br><span class="line">NSDictionary *xmlD = [NSDictionary dictionaryWithPlistString:[self xmlString]];</span><br><span class="line">NSData *data = [dic plistData];</span><br><span class="line">NSString *xmlString = [xmlD plistString];</span><br><span class="line">NSArray *keys = [dic allKeysSorted];</span><br><span class="line">NSArray *values = [dic allValuesSortedByKeys];</span><br><span class="line">BOOL isAge = [dic containsObjectForKey:@&quot;age&quot;];</span><br><span class="line">NSDictionary *newDic = [dic entriesForKeys:@[@&quot;age&quot;,@&quot;weight&quot;]];</span><br><span class="line">NSString *jsonString = [dic jsonStringEncoded];</span><br><span class="line">NSString *prettyJson = [dic jsonPrettyStringEncoded];</span><br><span class="line">NSDictionary *xmlDic = [NSDictionary dictionaryWithXML:[self xmlString]];</span><br><span class="line"></span><br><span class="line">NSMutableDictionary *muDic = [NSMutableDictionary dictionaryWithPlistData:plistD];</span><br><span class="line">NSMutableDictionary *xmlMuDic = [NSMutableDictionary dictionaryWithPlistString:[self xmlString]];</span><br><span class="line">[muDic popObjectForKey:@&quot;age&quot;];</span><br><span class="line">[muDic popEntriesForKeys:@[@&quot;age&quot;,@&quot;eat&quot;]];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">NSLog(@&quot;%@&quot;,xmlD);</span><br></pre></td></tr></table></figure></p>
<p>#pragma mark - NSDictionary 分类 之 dictionary value getter<br>    /*</p>
<pre><code>*/
</code></pre><p>#pragma mark - NSDictionary 分类 之 dictionary NSMutableDictionary<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+ (nullable NSMutableDictionary *)dictionaryWithPlistData:(NSData *)plist;</span><br><span class="line">根据指定的property list data 创建并返回一个字典；</span><br><span class="line"></span><br><span class="line">+ (nullable NSMutableDictionary *)dictionaryWithPlistString:(NSSting *)plist;</span><br><span class="line">根据指定的property list xml 字符串创建并返回一个字典；</span><br><span class="line"></span><br><span class="line">- (nullable id)popObjectForKey:(id)aKey;</span><br><span class="line">移除字典中指定key对应的值,并将这个移除的value返回；</span><br><span class="line"></span><br><span class="line">- (NSDictionary *)popEntriesForKeys:(NSArray *)keys;</span><br><span class="line">移除字典中一组指定key对应的一组值，并将移除的值返回；</span><br></pre></td></tr></table></figure></p>
<p>#pragma mark - NSDate 分类 之 component properties<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">NSDate框架结构：Component Properties，Date Modify，Date format。</span><br><span class="line">NSDate *date = [NSDate date];</span><br><span class="line">NSInteger year = date.year;</span><br><span class="line">NSInteger month = date.month;</span><br><span class="line">NSInteger day = date.day;</span><br><span class="line">NSInteger hour = date.hour;</span><br><span class="line">NSInteger minute = date.minute;</span><br><span class="line">NSInteger second = date.second;</span><br><span class="line">NSInteger nanoSecond = date.nanosecond;</span><br><span class="line">NSInteger weekday = date.weekday;</span><br><span class="line">NSInteger weekdayOrdinal = date.weekdayOrdinal;</span><br><span class="line">NSInteger weekofmonth = date.weekOfMonth;</span><br><span class="line">NSInteger weekofyear = date.weekOfYear;</span><br><span class="line">NSInteger yearForWeekOfYear = date.yearForWeekOfYear;</span><br><span class="line">NSInteger quater = date.quarter;// 季度</span><br><span class="line">BOOL isLeapMonth = date.isLeapMonth;</span><br><span class="line">BOOL isLeapYear = date.isLeapYear;</span><br><span class="line">BOOL isToday = date.isToday;</span><br><span class="line">BOOL isYesterDay = date.isYesterday;</span><br></pre></td></tr></table></figure></p>
<p>#pragma mark - NSDate 分类 之 date modify<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">- (nullable NSDate *)dateByAddingYears:(NSInteger)years;</span><br><span class="line">在日期的基础上增加指定的年数；</span><br><span class="line"></span><br><span class="line">- (nullable NSDate *)dateByAddingMonths:(NSInteger)months;</span><br><span class="line">在日期的基础上增加指定的月数；</span><br><span class="line"></span><br><span class="line">- (nullable NSDate *)dateByAddingWeeks:(NSInteger)weeks;</span><br><span class="line">在日期的基础上增加指定的周数；</span><br><span class="line"></span><br><span class="line">- (nullable NSDate *)dateByAddingDays:(NSInteger)days;</span><br><span class="line">在日期的基础上增加指定的天数；</span><br><span class="line"></span><br><span class="line">- (nullable NSDate *)dateByAddingHours:(NSInteger)hours;</span><br><span class="line">在日期的基础上增加指定的小时数；</span><br><span class="line"></span><br><span class="line">- (nullable NSDate *)dateByAddingMinutes:(NSInteger)minutes;</span><br><span class="line">在日期的基础上增加指定的分钟数。</span><br><span class="line"></span><br><span class="line">- (nullable NSDate *)dateByAddingSeconds:(NSInteger)seconds;</span><br><span class="line">在日期的基础上增加指定的秒数。</span><br><span class="line"></span><br><span class="line">NSDate *date = [NSDate date];</span><br><span class="line">NSDate *date11 = [date dateByAddingYears:2];</span><br><span class="line">NSDate *date22 = [date dateByAddingMonths:2];</span><br><span class="line">NSDate *date33 = [date dateByAddingDays:2];</span><br><span class="line">NSDate *date44 = [date dateByAddingWeeks:2];</span><br><span class="line">NSDate *date55 = [date dateByAddingHours:2];</span><br><span class="line">NSDate *date66 = [date dateByAddingMinutes:2];</span><br><span class="line">NSDate *date77 = [date dateByAddingSeconds:2];</span><br></pre></td></tr></table></figure></p>
<p>#pragma mark - NSDate 分类 之 date format<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">- (nullable NSString *)stringWithFormat:(NSString *)format;</span><br><span class="line">返回一个代表日期的格式化字符串：这里用到了国际化作为大家都不常用的一个类，NSLocale类是将与国家和语言相关的信息进行简单的组合，包括货币，文学方面的信息。 货币：货币的国际名称（人民币的国际货币名称是CNY）；货币符号（人民币的国际货币符号是¥） 文学：标点符号，文字的书写顺序（左右顺序），引用的起止符号等等 若做金融一类的应用可能会用到NSLocale这个类。https://www.jianshu.com/p/81c5ff4edf32</span><br><span class="line"></span><br><span class="line">- (nullable NSString *)stringWithFormat:(NSString *)format timeZone:(nullable NSTimeZone *)timeZone locale:(nullable NSLocale *)locale;</span><br><span class="line">返回一个代表日期的格式化字符串:time 时区，local：国家信息的组合</span><br><span class="line"></span><br><span class="line">- (nullable NSString *)stringWithISOFormat;</span><br><span class="line">返回一个代表日期的ISO08601格式的字符串。</span><br><span class="line"></span><br><span class="line">+ (nullable NSDate *)dateWithString:(NSString *)dateString format:(NSString *)format;</span><br><span class="line">返回从使用格式解释的给定字符串解析的日期；</span><br><span class="line"></span><br><span class="line">+ (nullable NSDate *)dateWithString:(NSString *)dateString format:(NSString *)format timeZone:(nullable NSTimeZone *)timeZone locale:(nullable NSLocale *)locale;</span><br><span class="line">返回从使用格式解释的给定字符串解析的日期；</span><br><span class="line"></span><br><span class="line">+ (nullable NSDate *)dateWithISOFormatString:(NSString *)dateString;</span><br><span class="line">返回从使用ISO08601格式解释的给定字符串解析的日期；</span><br><span class="line"></span><br><span class="line">NSDate *date = [NSDate date];</span><br><span class="line">NSString *string = [date stringWithFormat:@&quot;yyyy-MM-dd HH:mm:ss&quot;];</span><br><span class="line">NSString *string11 = [date stringWithFormat:@&quot;yyyy-MM-dd HH:mm:ss&quot; timeZone:[NSTimeZone timeZoneWithName:@&quot;America/Chicago&quot;] locale:[NSLocale localeWithLocaleIdentifier:@&quot;en_US&quot;]];</span><br><span class="line">NSString *isoString = [date stringWithISOFormat];</span><br><span class="line">NSDate *date11 = [NSDate dateWithString:string format:@&quot;yyyy-MM-dd HH:mm:ss&quot;];</span><br><span class="line">NSDate *date22 = [NSDate dateWithString:string format:@&quot;yyyy-MM-dd HH:mm:ss&quot; timeZone:[NSTimeZone timeZoneWithName:@&quot;America/Chicago&quot;] locale:[NSLocale localeWithLocaleIdentifier:@&quot;en_US&quot;]];</span><br><span class="line">NSDate *date33 = [NSDate dateWithISOFormatString:isoString];</span><br></pre></td></tr></table></figure></p>
<p>#pragma mark - NSData 分类 之 Hash<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">NSData框架结构：Hash，Encrypt and decrypt，Encode and decode，inflate and deflate，others；</span><br><span class="line">- (NSString *)md2String;</span><br><span class="line"> 返回的是md2 hash小写字母字符串</span><br><span class="line"></span><br><span class="line">- (NSData *)md2Data;</span><br><span class="line">返回的是md2 hash的NSData对象；</span><br><span class="line"></span><br><span class="line">NSString *password = @&quot;123589632541125&quot;;</span><br><span class="line">NSString *md2 = [password md2String];</span><br><span class="line">NSString *md4 = [password md4String];</span><br><span class="line">NSString *md5 = [password md5String];</span><br><span class="line">NSString *sha1 = [password sha1String];</span><br><span class="line">NSString *sha224 = [password sha224String];</span><br><span class="line">NSString *sha256 = [password sha256String];</span><br><span class="line">NSString *sha384 = [password sha384String];</span><br><span class="line">NSString *sha512 = [password sha512String];</span><br><span class="line"></span><br><span class="line">NSString *salt = @&quot;salt&quot;;</span><br><span class="line">NSString *md5Salt = [password hmacMD5StringWithKey:salt];// 俗称加盐:返回的是md5和指定的key进行加密返回的小写字母字符串；</span><br><span class="line">NSString *sha1Salt = [password hmacSHA1StringWithKey:salt];</span><br><span class="line">NSString *sha224Salt = [password hmacSHA224StringWithKey:salt];</span><br><span class="line">NSString *sha256Salt = [password hmacSHA256StringWithKey:salt];</span><br><span class="line">NSString *sha384Salt = [password hmacSHA384StringWithKey:salt];</span><br><span class="line">NSString *sha512Salt = [password hmacSHA512StringWithKey:salt];</span><br><span class="line">NSString *crc32 = [password crc32String];</span><br></pre></td></tr></table></figure></p>
<p>#pragma mark - NSData 分类 之 Encrypt and Decrypt<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (nullable NSData *)aes256EncryptWithKey:(NSData *)key iv:(nullable NSData *)iv;</span><br><span class="line">返回一个使用AES加密的NSData数据</span><br><span class="line">key：一个长度为16，24，32，128，192或者256位的key；</span><br><span class="line">iv：一个初始化长度为16（128位）的向量，如果不想使用iv就穿nil；</span><br><span class="line"></span><br><span class="line">- (nullable NSData *)aes256DecryptWithKey:(NSData *)key iv:(nullable NSData *)iv;</span><br><span class="line">返回使用AES进行解密的NSData数据；</span><br></pre></td></tr></table></figure></p>
<p>#pragma mark - NSData 分类 之 Encode and Decode<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NSData *data = [@&quot;可爱的人&quot; dataUsingEncoding:NSUTF8StringEncoding];</span><br><span class="line">NSString *string = [data utf8String];</span><br><span class="line">NSString *hexS = [data hexString];// 返回大写的十六进制字符串</span><br><span class="line">NSData *hexData = [NSData dataWithHexString:hexS];// 根据十六进制的字符串返回NSData数据；</span><br><span class="line">NSString *base64 = [data base64EncodedString];</span><br><span class="line">NSData *baseData = [NSData dataWithBase64EncodedString:base64];</span><br><span class="line">id value = [baseData jsonValueDecoded];// 对自己进行解码并返回NSDictionary或NSArray对象；</span><br></pre></td></tr></table></figure></p>
<p>#pragma mark - NSData 分类 之 Inflate and deflate(压缩和解压缩)<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Content-Encoding 的取值有 gzip、defalte、compress、identity、br 等，具体用到哪个需要跟服务端协商好。Xcode 提供的 zlib 可以实现这里的 gzip、defalte 这两种编码格式。</span><br><span class="line">gzip</span><br><span class="line">一种由文件压缩程序「Gzip，GUN zip」产生的编码格式，描述于 RFC 1952。这种编码格式是一种具有 32 位 CRC 的 Lempel-Ziv 编码（LZ77）；</span><br><span class="line">deflate</span><br><span class="line">由定义于 RFC 1950 的「ZLIB」编码格式与 RFC 1951 中描述的「DEFLATE」压缩机制组合而成的产物；</span><br><span class="line">由于 HTTP 1.1 的命名失误，deflate 当初应该命名为 zlib，因为其本身就是使用 zlib 格式编码，用 deflate 造成了与 DEFLATE 算法的混淆，事实上 Content-Encoding 为 gzip 和 deflate 时都可能使用 DEFLATE 算法。</span><br><span class="line"></span><br><span class="line">iOS开发中看，应用大多以XML或json的格式传输数据的，并且XML和JSON通常会比较大，所以客户端需要用下载或者上传的时间会比较长，这时我们可以考虑压缩数据，Gzip是一种比zip更优的压缩技术，它可以将数据压缩到60%，因此对客户端和服务器端来说就更加轻量级了。</span><br><span class="line">Gzip的优点：降低客户端对数据的下载时间和上传时间；节省流量；</span><br><span class="line"></span><br><span class="line">- (nullable NSData *)gzipInflate; 从gzip数据解压数据</span><br><span class="line">- (nullable NSData *)gzipDefalte; 根据默认的压缩级别，将数据压缩到gzip</span><br><span class="line">- (nullable NSData *)zlibInflate; 从zlib-compress数据解压缩数据</span><br><span class="line">- (nullable NSData *)zlibDeflate; 以默认的压缩级别将数据压缩为zlib0compressed；</span><br></pre></td></tr></table></figure></p>
<p>#pragma mark - NSData 分类 之 Others<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+ (nullable NSData *)dataNamed:(NSString *)name;</span><br><span class="line">从main bundle 中的文件(这里的文件不能有后缀名)中创建data数据，类似于[UIImage imageNamed:]</span><br><span class="line"></span><br><span class="line">NSString *path = [[NSBundle mainBundle] pathForResource:@&quot;comment&quot; ofType:@&quot;jpeg&quot;];</span><br><span class="line">NSData *imageD = [NSData dataWithContentsOfFile:path];</span><br><span class="line">NSData *data = [NSData dataNamed:@&quot;File&quot;];</span><br></pre></td></tr></table></figure></p>
<p>{</p>
<p>#pragma mark - NSBundle 分类<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+ (NSArray&lt;NSNumber *&gt; *)preferredScales;</span><br><span class="line">获取一个NSNumber数组，展示path scale搜索下的最好顺序；</span><br><span class="line"></span><br><span class="line">+ (nullable NSString *)pathForScaledResource:(NSString *)name ofType:(nullable NSString *)ext inDirectory:(NSString *)bundlePath;</span><br><span class="line">返回由指定名称和扩展名标识的资源文件的完成路径名，并位于给定的捆绑目录中。它首先用当前屏幕的比例（例如@2x）搜索文件，然后从较高比例搜索到较低比例；</span><br><span class="line">bundlePath：要搜索的文件的上一级目录路径；</span><br><span class="line">return：资源文件的全路径，如果文件找不到就返回nil，如果bundlepath参数指定的bundle不存在或者是不可读的目录，也会返回nil；</span><br><span class="line">ext：如果extension是一个空的字符串或者nil，那么extension就假设不存在，文件就是第一个和名字匹配的那个。</span><br><span class="line"></span><br><span class="line">NSArray *scales = [NSBundle preferredScales];</span><br><span class="line">NSString *path = [NSBundle pathForScaledResource:@&quot;comment&quot; ofType:@&quot;jpeg&quot; inDirectory:@&quot;/Users/aker/work/MyLessonDemo2019/MyLessonDemo2019&quot;];</span><br><span class="line">NSString *path1 = [[NSBundle mainBundle] pathForScaledResource:@&quot;comment&quot; ofType:@&quot;jpeg&quot;];</span><br><span class="line">NSString *path2 = [[NSBundle mainBundle] pathForScaledResource:@&quot;comment&quot; ofType:@&quot;jpeg&quot; inDirectory:@&quot;/Users/aker/work/MyLessonDemo2019/MyLessonDemo2019&quot;];</span><br></pre></td></tr></table></figure></p>
<p>#pragma mark - NSAttributedString 分类<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">框架结构：</span><br><span class="line">基本，get YYText attribute as property，query for YYText，create attachment string for YYText，Utility，set character attribute，set character attribute as property，set paragraph attribute as property，set YYText attribute as property，set discontinuous attribute for range，convenience methods for text highlight，utilities，get paragraph attribute as property，get character attribute as property，retrieving character attribute Information；</span><br><span class="line"></span><br><span class="line">- (nullable NSData *)archiveToData;</span><br><span class="line">将字符串归档到数据库；</span><br><span class="line"></span><br><span class="line">+ (nullable instancetype)unarchiveFromData:(NSData *)data;</span><br><span class="line">从数据中接档出字符串；</span><br><span class="line"></span><br><span class="line">NSAttributedString *att = [[NSAttributedString alloc]initWithString:@&quot;这是一个空白页面&quot; attributes:@&#123;NSForegroundColorAttributeName:[UIColor blackColor],NSFontAttributeName:[UIFont systemFontOfSize:20 weight:UIFontWeightBold]&#125;];</span><br><span class="line">NSData *data = [att archiveToData];</span><br><span class="line">NSAttributedString *attr = [NSAttributedString unarchiveFromData:data];</span><br></pre></td></tr></table></figure></p>
<p>#pragma mark - NSAttributedString 分类 Retrieving character attribute information（检索字符串属性信息）<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@property (nullable, nonatomic, copy, readonly) NSDictionary&lt;NSString *, id&gt; *attributes;</span><br><span class="line">返回第一个字符的属性。</span><br><span class="line"></span><br><span class="line">- (nullable NSDictionary&lt;NSString *, id&gt; *)attributesAtIndex:(NSUInteger)index;</span><br><span class="line">返回给定索引的字符的属性，如果索引位于接收者字符的末尾，那么就会引起NSRangeException错误；</span><br><span class="line"></span><br><span class="line">- (nullable id)attribute:(NSString *)attributeName atIndex:(NSUInteger)index;</span><br><span class="line">给定索引给定字符名的属性的值；</span><br></pre></td></tr></table></figure></p>
<p>#pragma mark - NSAttributedString 分类  其他部分<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">NSAttributedString *att = [[NSAttributedString alloc]initWithString:@&quot;这是一个空白页面&quot; attributes:@&#123;NSForegroundColorAttributeName:[UIColor blackColor],NSFontAttributeName:[UIFont systemFontOfSize:20 weight:UIFontWeightBold]&#125;];</span><br><span class="line">NSData *data = [att archiveToData];</span><br><span class="line">NSAttributedString *attr = [NSAttributedString unarchiveFromData:data];</span><br><span class="line">NSDictionary *attribute = att.attributes;</span><br><span class="line">NSDictionary *attribute111 = [att attributesAtIndex:5];</span><br><span class="line">id atttribute444 = [att attribute:NSForegroundColorAttributeName atIndex:1];</span><br><span class="line">UIFont *font = att.font;</span><br><span class="line">UIFont *font1 = [att fontAtIndex:2];</span><br><span class="line">NSString *plainT = [att plainTextForRange:NSMakeRange(0, 5)];</span><br></pre></td></tr></table></figure></p>
<h4 id="富文本的简单demo"><a href="#富文本的简单demo" class="headerlink" title="富文本的简单demo"></a>富文本的简单demo</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">     YYLabel *attLabel = [[YYLabel alloc]initWithFrame:CGRectMake(0, 0, kScreenWidthForApp(), 300)];</span><br><span class="line">     attLabel.backgroundColor = kLightMintColor();</span><br><span class="line">     attLabel.font = [UIFont systemFontOfSize:20 weight:UIFontWeightHeavy];</span><br><span class="line">     [self.view addSubview:attLabel];</span><br><span class="line">     NSMutableAttributedString *att = [[NSMutableAttributedString alloc]initWithString:@&quot;这是一个YYText小呆毛&quot; attributes:@&#123;NSForegroundColorAttributeName:kTitleColor,NSFontAttributeName:[UIFont systemFontOfSize:15 weight:UIFontWeightRegular]&#125;];</span><br><span class="line">     </span><br><span class="line">   //  content：附件（UIImage，UIView，CALayer）</span><br><span class="line">   //  contentMode：附件的内容模式</span><br><span class="line">   //  width：布局中附加内容的宽</span><br><span class="line">   //  ascent：布局中附件内容的ascent（这个值就是把图片转化为字符时要展示的字符大小）</span><br><span class="line">   //  descent：布局中附件内容的descent（这个值就是把图片转化为字符时要展示的字符大小）</span><br><span class="line">    NSMutableAttributedString *attach = [NSMutableAttributedString attachmentStringWithContent:[UIImage imageNamed:@&quot;test&quot;] contentMode:UIViewContentModeScaleAspectFit width:100 ascent:20 descent:20];</span><br><span class="line">    </span><br><span class="line">    // 图片</span><br><span class="line">    NSMutableAttributedString *attach11 = [NSMutableAttributedString attachmentStringWithContent:[UIImage imageNamed:@&quot;icon2019&quot;] contentMode:UIViewContentModeScaleAspectFit attachmentSize:CGSizeMake(50, 50) alignToFont:[UIFont systemFontOfSize:15 weight:UIFontWeightRegular] alignment:YYTextVerticalAlignmentCenter];</span><br><span class="line">    </span><br><span class="line">    // 从foursquare图像创建并返回附件，就好像它是表情符号emoji一样</span><br><span class="line">    NSMutableAttributedString *attach3 = [NSMutableAttributedString attachmentStringWithEmojiImage:[UIImage imageNamed:@&quot;MoreBill&quot;] fontSize:15];</span><br><span class="line">    </span><br><span class="line">    // gif 表情符号</span><br><span class="line">    NSString *path = [[NSBundle mainBundle] pathForResource:@&quot;tenor&quot; ofType:@&quot;gif&quot;];</span><br><span class="line">    NSData *imageD = [NSData dataWithContentsOfFile:path];</span><br><span class="line">    UIImage *aniImage = [UIImage sd_animatedGIFWithData:imageD];</span><br><span class="line">    NSMutableAttributedString *aniAttach = [NSMutableAttributedString attachmentStringWithEmojiImage:aniImage fontSize:50];</span><br><span class="line">    </span><br><span class="line">    [att appendAttributedString:attach];</span><br><span class="line">    [att appendAttributedString:attach11];</span><br><span class="line">    [att insertAttributedString:attach3 atIndex:0];</span><br><span class="line">    [att appendAttributedString:aniAttach];</span><br><span class="line">    </span><br><span class="line">    attLabel.attributedText = att;</span><br><span class="line"></span><br><span class="line">// Utility</span><br><span class="line">     - (NSRange)rangeOfAll;</span><br><span class="line">     返回长度区间</span><br><span class="line">     </span><br><span class="line">     - (BOOL)isShareAttributesInAllRanges;</span><br><span class="line">     如果是YES，它在整个文本范围内共享相同的属性；</span><br><span class="line">     </span><br><span class="line">     - (BOOL)canDrawWithUIKit;</span><br><span class="line">     如果是YES，则可以使用[drawWithRect：options：context：]方法绘制或使用UIKit显示。如果NO，则应使用CoreText或YYText进行绘制；</span><br><span class="line">     如果方法返回NO，则意味着至少有一个属性不受UIKit支持（如CTParagraphStyleRef）。如果在UIKit中显示此字符串，它可能会丢失一些属性，甚至导致应用程序崩溃；</span><br></pre></td></tr></table></figure>
<p>#pragma mark - NSMutableAttributedString分类<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">- (void)setAttributes:(nullable NSDictionary&lt;NSString *,id&gt; *)attributes;</span><br><span class="line">为整个字符串设置属性，旧的属性将被移除；attributes如果为nil表示移除所有属性；</span><br><span class="line"></span><br><span class="line">- (void)removeAttributesInRange:(NSRange)range;</span><br><span class="line">为字符串指定区间移除所有属性</span><br><span class="line"></span><br><span class="line">YYLabel *label2 = [[YYLabel alloc]initWithFrame:CGRectMake(0, 120 + kTopHeight(), kScreenWidthForApp(), 100)];</span><br><span class="line">label2.backgroundColor = [UIColor whiteColor];</span><br><span class="line">[self.view addSubview:label2];</span><br><span class="line"></span><br><span class="line">NSMutableAttributedString *label2Att = [[NSMutableAttributedString alloc]initWithString:@&quot;NSMutableAttributedString&quot; attributes:@&#123;NSForegroundColorAttributeName:kTitleColor,NSFontAttributeName:[UIFont boldSystemFontOfSize:20]&#125;];</span><br><span class="line"></span><br><span class="line">attach11.textShadow = [YYTextShadow shadowWithColor:[UIColor redColor] offset:CGSizeMake(5, 5) radius:0];</span><br><span class="line">//     文字阴影，只有字符可以，attachment设置没有效果；</span><br><span class="line">att.textShadow = [YYTextShadow shadowWithColor:[UIColor redColor] offset:CGSizeMake(20, 20) radius:0];// 外阴影</span><br><span class="line">att.textInnerShadow = [YYTextShadow shadowWithColor:[UIColor redColor] offset:CGSizeMake(5, 5) radius:0];// 内阴影</span><br><span class="line">YYTextDecoration * dec = [YYTextDecoration decorationWithStyle:YYTextLineStylePatternCircleDot width:[NSNumber numberWithFloat:100] color:kLightOrangeColor()];</span><br><span class="line">//    label2Att.textUnderline = dec;</span><br><span class="line"></span><br><span class="line">[label2Att setTextUnderline:dec range:NSMakeRange(0, label2Att.length)];</span><br><span class="line"></span><br><span class="line">// 设置点击事件</span><br><span class="line">[label2Att setTextHighlightRange:NSMakeRange(0, label2Att.length/2) color:[UIColor orangeColor] backgroundColor:[UIColor yellowColor] userInfo:@&#123;@&quot;label&quot;:@&quot;label2Att&quot;&#125; tapAction:^(UIView * _Nonnull containerView, NSAttributedString * _Nonnull text, NSRange range, CGRect rect) &#123;</span><br><span class="line">NSLog(@&quot;🍄---🍄---🍄---🍄---🍄---🍄---&quot;);</span><br><span class="line">&#125; longPressAction:^(UIView * _Nonnull containerView, NSAttributedString * _Nonnull text, NSRange range, CGRect rect) &#123;</span><br><span class="line">NSLog(@&quot;🌹----🌹----🌹----🌹----🌹----&quot;);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[label2Att insertString:@&quot;label  &quot; atIndex:0];</span><br><span class="line">[label2Att appendString:@&quot;fjajgla&quot;];</span><br></pre></td></tr></table></figure></p>
<p>#pragma mark - NSArray<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">NSString *path = [[NSBundle mainBundle] pathForResource:@&quot;array&quot; ofType:@&quot;plist&quot;];</span><br><span class="line">NSData *data = [NSData dataWithContentsOfFile:path];</span><br><span class="line">NSArray *array = [NSArray arrayWithPlistData:data];</span><br><span class="line">NSData *data1 = [array plistData];</span><br><span class="line">id object = [array randomObject];// 随机数</span><br><span class="line">[array objectOrNilAtIndex:2];// 返回某一index处的对象，索引越界就返回nil。类似ObjectAtIndex：但是不会抛出异常；</span><br><span class="line">NSString *json = [array jsonStringEncoded];// 将对象转化为json字符串，发生错误就返回nil</span><br><span class="line">NSString *jsonPre = [array jsonPrettyStringEncoded];// 将对象转化为json字符串formatted，如果发生错误就返回nil；</span><br><span class="line">NSLog(@&quot;json%@&quot;,json);</span><br><span class="line">NSLog(@&quot;jsonPre%@&quot;,jsonPre);</span><br></pre></td></tr></table></figure></p>
<p>#pragma mark - NSMuatableArray<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">NSString *path = [[NSBundle mainBundle] pathForResource:@&quot;array&quot; ofType:@&quot;plist&quot;];</span><br><span class="line">NSData *data = [NSData dataWithContentsOfFile:path];</span><br><span class="line">NSMutableArray *array = [NSMutableArray arrayWithPlistData:data];</span><br><span class="line">[array removeFirstObject];</span><br><span class="line">[array removeLastObject];</span><br><span class="line">[array insertObjects:array atIndex:0];</span><br><span class="line">[array reverse];// 将数组中的元素进行反向排序；</span><br><span class="line">[array shuffle];// 对这个数组中的对象进行随机排序；</span><br></pre></td></tr></table></figure></p>
<p>#pragma mark - MKAnnotationView 分类<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// mapview</span><br><span class="line">MKAnnotationView *ano = [[MKAnnotationView alloc]initWithFrame:CGRectMake(16, 300, kScreenWidthForApp() - 32, 300)];</span><br><span class="line">ano.imageURL = [NSURL URLWithString:testURL()];// 为此属性设置一个新值将取消先前的请求操作并创建一个新的请求操作来获取图像。设置为nil以清除图片和图片URL；</span><br><span class="line">[ano setImageWithURL:[NSURL URLWithString:testURL()] placeholder:placeholderImage() options:YYWebImageOptionUseNSURLCache manager:nil progress:nil transform:nil completion:nil];</span><br><span class="line">[self.view addSubview:ano];</span><br></pre></td></tr></table></figure></p>
<p>#pragma mark - CALayer 分类 之 YYAdd 和 YYWebImage（类似SDWebImage）<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">图片快速截图，图片旋转等操作；</span><br><span class="line">UIImageView *resultImageV = [UIImageView createImageViewWithFrame:CGRectMake(0, kTopHeight(), kScreenWidthForApp(), 300) imageName:nil];</span><br><span class="line">resultImageV.contentMode = UIViewContentModeScaleAspectFit;</span><br><span class="line">resultImageV.backgroundColor = [UIColor orangeColor];</span><br><span class="line">[self.view addSubview:resultImageV];</span><br><span class="line"></span><br><span class="line">UIImageView *imageV = [[UIImageView alloc]initWithFrame:CGRectMake(0, 320 + kTopHeight(), kScreenWidthForApp(), 300)];</span><br><span class="line">imageV.backgroundColor = kLightLightGrayColor();</span><br><span class="line">[imageV setImageWithURL:[NSURL URLWithString:testURL()] placeholder:placeholderImage()];</span><br><span class="line">[self.view addSubview:imageV];</span><br><span class="line"></span><br><span class="line">CAShapeLayer *shapler = [CAShapeLayer layer];</span><br><span class="line">[shapler setImageWithURL:[NSURL URLWithString:@&quot;https://desk-fd.zol-img.com.cn/t_s960x600c5/g5/M00/02/04/ChMkJ1bKx-iISS3nAAhg0DWRhY0AALH6gDF3lkACGDo264.jpg&quot;] placeholder:placeholderImage()];</span><br><span class="line">shapler.frame = CGRectMake(0, 0, 160, 160);</span><br><span class="line">[imageV.layer addSublayer:shapler];</span><br><span class="line"></span><br><span class="line">CAShapeLayer *shap11 = [CAShapeLayer layer];</span><br><span class="line">[shap11 setImageWithURL:[NSURL URLWithString:@&quot;https://www.fotor.com/images2/features/photo_effects/e_bw.jpg&quot;] placeholder:placeholderImage()];</span><br><span class="line">shap11.frame = CGRectMake(100, 200, 80, 80);</span><br><span class="line">[imageV.layer addSublayer:shap11];</span><br><span class="line"></span><br><span class="line">[imageV.layer setLayerShadow:kLightLavanderColor() offset:CGSizeMake(5, 5) radius:0];</span><br><span class="line"></span><br><span class="line">// 内容更改时，向图层内容添加淡入淡出动画。</span><br><span class="line">[shap11 addFadeAnimationWithDuration:2.0 curve:UIViewAnimationCurveEaseIn];</span><br><span class="line"></span><br><span class="line">NSData *pdfData = [imageV.layer snapshotPDF];</span><br><span class="line"></span><br><span class="line">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(5 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">shap11.transformDepth = 34/1000;// 深度</span><br><span class="line">shap11.transformRotation = 60;</span><br><span class="line">shapler.transformScale = 1.5;</span><br><span class="line">UIImage *snapImage = [imageV.layer snapshotImage];</span><br><span class="line">resultImageV.image = snapImage;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>}</p>
<p>#pragma mark - YYReachablity<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">这里涉及到两个枚举，一个用来区分WWAN 和 WIFI，另外一个用来区分WWAN内部的2G，3G，4G内部的网络类型；</span><br><span class="line">Mbps=Mbit/s 即兆比特每秒（1，000，000 bit/s），Million bits per second 的缩写，是一种传输速率单位，指每秒传输的位（比特）数量；</span><br><span class="line"></span><br><span class="line">typedef NS_ENUM(NSUInteger, YYReachabilityStatus) &#123;</span><br><span class="line">YYReachabilityStatusNone  = 0, ///&lt; Not Reachable</span><br><span class="line">YYReachabilityStatusWWAN  = 1, ///&lt; Reachable via WWAN (2G/3G/4G)</span><br><span class="line">YYReachabilityStatusWiFi  = 2, ///&lt; Reachable via WiFi</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">typedef NS_ENUM(NSUInteger, YYReachabilityWWANStatus) &#123;</span><br><span class="line">YYReachabilityWWANStatusNone  = 0, ///&lt; Not Reachable vis WWAN</span><br><span class="line">YYReachabilityWWANStatus2G = 2, ///&lt; Reachable via 2G (GPRS/EDGE)       10~100Kbps</span><br><span class="line">YYReachabilityWWANStatus3G = 3, ///&lt; Reachable via 3G (WCDMA/HSDPA/...) 1~10Mbps</span><br><span class="line">YYReachabilityWWANStatus4G = 4, ///&lt; Reachable via 4G (eHRPD/LTE)       100Mbps</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">@property(nonatomic,readonly) SCNetworkReachabilityFlags flags;</span><br><span class="line">这里用到了一个框架SystemConfiguration，这个枚举SCNetworkReachbilityFlags 就在这个框架里面，这里引入头文件#import &lt;SystemConfiguration/SystemConfiguration.h&gt;。</span><br><span class="line">SCNetworkReachabilityFlags flags = [YYReachability reachability].flags;// 指示指定的网络节点名称或地址是否可达，是否需要连接以及建立连接时是否需要某些用户干预的标志；</span><br><span class="line">* kSCNetworkReachabilityFlagsTransientConnection 该标志表示可以通过临时连接（如APP）访问指定的节点名称或地址；</span><br><span class="line">* kSCNetworkReachabilityFlagsReachable 该标志表示可以使用当前的网络配置来访问指定的节点名称或地址</span><br><span class="line">* kSCNetworkReachabilityFlagsConnectionRequired 该标志表示可以使用当前网络配置访问指定的节点名称或地址，但必须首先建立连接，作为一个例子，这个状态将返回一个当前不活动的拨号连接，但可以处理目标系统的网络流量；</span><br><span class="line">* kSCNetworkReachabilityFlagsConnectionOnTraffic 该标志表示可以使用当前网络配置访问指定的节点名称或地址，但必须首先建立连接。任何指向指定名称或地址的流量都将启动连接。注意：此标志以前名为kSCNetworkReachabilityFlagsConnectionAutomatic。</span><br><span class="line">* kSCNetworkReachabilityFlagsInterventionRequired 该标志表示可以使用当前网络配置来访问指定的节点名称或地址，但是另外需要某种形式的用户干预来建立此链接，例如提供密码，身份验证令牌等。注意：目前这个标志只会出现在你有拨号流量配置（ConnectionOnTraffic）的情况下，在这种情况下，已经进行了连接尝试，并且出现了一些错误（例如没有拨号音，没有应答，坏的密码，......）在自动连接尝试期间遇到。在这种情况下，PPP控制器将停止尝试建立连接，直到用户干预。</span><br><span class="line">* kSCNetworkReachabilityFlagsConnectionOnDemand 该标志表示可以使用当前的网络配置访问指定的节点名称或地址，但必须首先建立连接，连接将由CFSocketStream API”按需“建立，其他API不会建立连接。</span><br><span class="line">* kSCNetworkReachabilityFlagsIsLocalAddress 该标志表示指定的节点名称或地址是与当前系统上的网络连接关联的节点名称或地址。</span><br><span class="line">* kSCNetworkReachabilityFlagsIsDirect 该标志表示到指定节点名称或地址的网络流量不会通过网关，而是直接路由到系统中的某个接口；</span><br><span class="line">* kSCNetworkReachabilityFlagsIsWWAN 该标志表示可以通过 EDGE，GPRS或其他”cell“连接到达指定节点名称或地址。</span><br><span class="line"></span><br><span class="line">YYReachabilityStatus status = [YYReachability reachability].status;</span><br><span class="line">YYReachabilityWWANStatus wwanStatus = [YYReachability reachability].wwanStatus;</span><br><span class="line">GPRS（General Packet Radio Service）是通用分组无线服务技术的简称，它是GSM移动电话用户可用的一种移动数据业务，属于第二代移动通信中的数据传输技术。GPRS可说是GSM的延续。GPRS和以往连续在频道传输的方式不同，是以封包（Packet）式来传输，因此使用者所负担的费用是以其传输资料单位计算，并非使用其整个频道，理论上较为便宜。GPRS的传输速率可提升至56甚至114Kbps。</span><br><span class="line">EDGE（Enhanced Data Rate for GSM Evolution ，增强型数据速率GSM演进技术）是一种从GSM到3G的过渡技术，它主要是在GSM系统中采用了一种新的调制方法，即最先进的多时隙操作和8PSK调制技术。由于8PSK可将现有GSM网络采用的GMSK调制技术的信号空间从2扩展到8，从而使每个符号所包含的信息是原来的4倍。EDGE是一种介于第二代移动网络与第三代移动网络之间的过渡技术，因此也有人称它为&quot;二代半&quot;技术。</span><br><span class="line">WCDMA亦称宽带码分多址，是一种第三代无线通讯技术，是种由3GPP具体制定的，基于GSM MAP核心网，UTRAN（UMTS陆地无线接入网）为无线接口的第三代移动通信系统。 目前WCDMA有Release 99、Release 4、Release 5、Release 6等版本。 目前中国联通采用的此种3G通讯标准。</span><br><span class="line">HSDPA（High Speed Downlink Packet Access)高速下行分组接入，是一种移动通信协议，亦称为3.5G(3½G)。该协议在WCDMA下行链路中提供分组数据业务，在一个5MHz载波上的传输速率可达8-10 Mbit/s（如采用MIMO技术，则可达20 Mbit/s）。在具体实现中，采用了自适应调制和编码（AMC）、多输入多输出（MIMO）、混合自动重传请求（HARQ）、快速调度、快速小区选择等技术。</span><br><span class="line">HSUPA (high speed uplink packet access)高速上行链路分组接入。HSUPA通过采用多码传输、HARQ、基于Node B的快速调度等关键技术，使得单小区最大上行数据吞吐率达到5.76Mbit/s，大大增强了WCDMA上行链路的数据业务承载能力和频谱利用率。在引入HSDPA技术大幅提高下行链路的数据传输速率和吞吐量之后，为满足上行速率要求更高的业务发展需求，3GPP进一步开展了上行链路增强技术的研究。高速上行分组接入（High Speed Uplink Packet Access，HSUPA）即是3GPP协议体系在R6版本中引入的无线侧上行链路增强技术。HSUPA通过采用多码传输、HARQ、基于Node B的快速调度等关键技术，使得单小区最大上行数据吞吐率达到5.76Mbit/s，大大增强了WCDMA上行链路的数据业务承载能力和频谱利用率。TD-SCDMA系统与WCDMA系统采用的HSUPA技术较为类似，但TD-SCDMA系统的标准化进展稍滞后于WCDMA。</span><br><span class="line">LTE（Long Term Evolution，长期演进)是由3GPP（The 3rd Generation Partnership Project，第三代合作伙伴计划）组织制定的UMTS（Universal Mobile Telecommunications System，通用移动通信系统）技术标准的长期演进，于2004年12月在3GPP多伦多会议上正式立项并启动。LTE系统引入了OFDM（Orthogonal Frequency Division Multiplexing，正交频分复用）和MIMO（Multi-Input &amp; Multi-Output，多输入多输出）等关键技术，显著增加了频谱效率和数据传输速率（20M带宽2X2MIMO在64QAM情况下，理论下行最大传输速率为201Mbps，除去信令开销后大概为150Mbps，但根据实际组网以及终端能力限制，一般认为下行峰值速率为100Mbps，上行为50Mbps），并支持多种带宽分配：1.4MHz，3MHz，5MHz，10MHz，15MHz和20MHz等，且支持全球主流2G/3G频段和一些新增频段，因而频谱分配更加灵活，系统容量和覆盖也显著提升。</span><br><span class="line"></span><br><span class="line">BOOL reachable = [YYReachability reachability].reachable;// 直接判断网络是否可达；</span><br><span class="line"></span><br><span class="line">+ (instancetype)reachability;</span><br><span class="line">该方法的作用就是监测默认路由的可达性。</span><br><span class="line"></span><br><span class="line">[YYReachability reachability].notifyBlock = ^(YYReachability * _Nonnull reachability) &#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">// 该属性的作用就是当网络状态发生变化后，就会在主线程通过block进行回调；</span><br><span class="line"></span><br><span class="line">YYReachability *reachability = [YYReachability reachabilityWithHostname:@&quot;https://www.baidu.com&quot;];// 判断给定的host的可达性</span><br><span class="line">YYReachability *reach = [YYReachability reachabilityWithAddress:@&quot;128.106.1.111&quot;];//判断给定IP地址的可达性</span><br></pre></td></tr></table></figure></p>
<p>#pragma mark - 线程安全计数器YYSentinel<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">YYSentinel是一个线程计数器，可以在一些多线程环境下使用；</span><br><span class="line"></span><br><span class="line">@property(readonly)int32_t value;</span><br><span class="line">返回计数器当前值。</span><br><span class="line"></span><br><span class="line">- (int32_t)increase;</span><br><span class="line">自动增加计数器的值。</span><br></pre></td></tr></table></figure></p>
<p>#pragma mark - 线程安全的可变数组子类YYThreadSafeArray部分<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">这个类主要就是线程安全可变数组的简单实现；通常访问性能对于NSMutableArray，但高于使用@synchoronized，NSLock或pthread_mutex_t;与NSArray(YYAdd)和NSMutableArray(YYAdd)中的自定义方法兼容；快速枚举enumerate(for...in)和枚举器不是线程安全的，使用block进行遍历枚举。当使用block/callblock进行遍历时，不要向block/callblock内部的数组发送消息。</span><br><span class="line">NSArray *array = @[@&quot;a&quot;,@&quot;ka&quot;,@&quot;dga&quot;,@&quot;fsg&quot;,@&quot;gshsh&quot;];</span><br><span class="line">[array enumerateObjectsUsingBlock:^(id  _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123;</span><br><span class="line"></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure></p>
<p>#pragma mark - YYTimer 定时器<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">YYTimer是基于GCD的线程安全的计数器，它和NSTimer类似的API，YYTimer对象和NSTimer在下面几个方式不同：</span><br><span class="line">* 它使用GCD产生时钟tick，不受runloop影响；</span><br><span class="line">* 它对target是weak修饰，所以可以避免引用循环；</span><br><span class="line">* 它在主线程上开启</span><br><span class="line"></span><br><span class="line">- (void)timerCreate:(UIButton *)button &#123;</span><br><span class="line">// 信号量：semaphore</span><br><span class="line">//    dispatch_semaphore_t sema = dispatch_semaphore_create(1); // 创建一个信号量</span><br><span class="line">//    dispatch_semaphore_signal(sema);// 发送一个信号</span><br><span class="line">//    dispatch_semaphore_wait(sema, 10);// 等待信号</span><br><span class="line"></span><br><span class="line">// 必须设置为全局变量，否则运行一次不再运行；</span><br><span class="line">YYTimer *timer = [YYTimer timerWithTimeInterval:1 target:self selector:@selector(yyTimerTexrst:) repeats:YES];</span><br><span class="line">[timer fire];</span><br><span class="line">self.timer = timer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)yyTimerTexrst:(YYTimer *)timer &#123;</span><br><span class="line">self.timerCount -= 1;</span><br><span class="line">NSLog(@&quot;timeCount: = %li&quot;,self.timerCount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>#pragma mark - 事物 YYTransaction<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">YYTransaction让你在当前runloop休眠之前执行一个selector一次；</span><br><span class="line"></span><br><span class="line">+ (YYTransaction *)transactionWithTarget:(id)target selector:(SEL)selector;</span><br><span class="line">target: 一个指定的target，这个target被持有，知道runloop结束；</span><br><span class="line">selector：target的selector；</span><br></pre></td></tr></table></figure></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/03/25/iOS通用链接配置（点击网页直接打开APP的详情页面）/" rel="next" title="iOS通用链接配置（点击网页直接打开APP的详情页面）">
                <i class="fa fa-chevron-left"></i> iOS通用链接配置（点击网页直接打开APP的详情页面）
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">aHuang</p>
              <p class="site-description motion-element" itemprop="description">心态在线，激情在线，健康在线，才能创造未来！</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#富文本的简单demo"><span class="nav-number">1.</span> <span class="nav-text">富文本的简单demo</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-../images/haha.jpg"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">aHuang</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
